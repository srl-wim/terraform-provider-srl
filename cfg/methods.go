/*
Package srl_yang is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /Users/henderiw/CodeProjects/go/pkg/mod/github.com/openconfig/ygot@v0.8.3/genutil/names.go
using the following YANG input files:
	- ../yang/srl/srl_nokia-aaa-tacacs.yang
	- ../yang/srl/srl_nokia-aaa-types.yang
	- ../yang/srl/srl_nokia-aaa.yang
	- ../yang/srl/srl_nokia-acl.yang
	- ../yang/srl/srl_nokia-aft.yang
	- ../yang/srl/srl_nokia-aggregate-routes.yang
	- ../yang/srl/srl_nokia-app-mgmt.yang
	- ../yang/srl/srl_nokia-bfd.yang
	- ../yang/srl/srl_nokia-bgp.yang
	- ../yang/srl/srl_nokia-boot.yang
	- ../yang/srl/srl_nokia-common.yang
	- ../yang/srl/srl_nokia-configuration.yang
	- ../yang/srl/srl_nokia-dns.yang
	- ../yang/srl/srl_nokia-extensions.yang
	- ../yang/srl/srl_nokia-ftp.yang
	- ../yang/srl/srl_nokia-gnmi-server.yang
	- ../yang/srl/srl_nokia-icmp.yang
	- ../yang/srl/srl_nokia-if-ip.yang
	- ../yang/srl/srl_nokia-interfaces-ip-dhcp.yang
	- ../yang/srl/srl_nokia-interfaces-nbr.yang
	- ../yang/srl/srl_nokia-interfaces-vlans.yang
	- ../yang/srl/srl_nokia-interfaces.yang
	- ../yang/srl/srl_nokia-ip-route-tables.yang
	- ../yang/srl/srl_nokia-json-rpc.yang
	- ../yang/srl/srl_nokia-linux.yang
	- ../yang/srl/srl_nokia-lldp-types.yang
	- ../yang/srl/srl_nokia-lldp.yang
	- ../yang/srl/srl_nokia-load-balancing.yang
	- ../yang/srl/srl_nokia-logging.yang
	- ../yang/srl/srl_nokia-maintenance-mode.yang
	- ../yang/srl/srl_nokia-mpls-route-tables.yang
	- ../yang/srl/srl_nokia-mpls.yang
	- ../yang/srl/srl_nokia-mtu.yang
	- ../yang/srl/srl_nokia-network-instance-mtu.yang
	- ../yang/srl/srl_nokia-network-instance.yang
	- ../yang/srl/srl_nokia-next-hop-groups.yang
	- ../yang/srl/srl_nokia-ntp.yang
	- ../yang/srl/srl_nokia-packet-match-types.yang
	- ../yang/srl/srl_nokia-platform-acl.yang
	- ../yang/srl/srl_nokia-platform-chassis.yang
	- ../yang/srl/srl_nokia-platform-control.yang
	- ../yang/srl/srl_nokia-platform-cpu.yang
	- ../yang/srl/srl_nokia-platform-disk.yang
	- ../yang/srl/srl_nokia-platform-fabric.yang
	- ../yang/srl/srl_nokia-platform-fan.yang
	- ../yang/srl/srl_nokia-platform-ip-mpls-fwd-resources.yang
	- ../yang/srl/srl_nokia-platform-lc.yang
	- ../yang/srl/srl_nokia-platform-memory.yang
	- ../yang/srl/srl_nokia-platform-mtu.yang
	- ../yang/srl/srl_nokia-platform-psu.yang
	- ../yang/srl/srl_nokia-platform-qos.yang
	- ../yang/srl/srl_nokia-platform-redundancy.yang
	- ../yang/srl/srl_nokia-platform-resource-monitoring.yang
	- ../yang/srl/srl_nokia-platform.yang
	- ../yang/srl/srl_nokia-policy-types.yang
	- ../yang/srl/srl_nokia-qos.yang
	- ../yang/srl/srl_nokia-rib-bgp.yang
	- ../yang/srl/srl_nokia-routing-policy.yang
	- ../yang/srl/srl_nokia-sflow.yang
	- ../yang/srl/srl_nokia-snmp-trace.yang
	- ../yang/srl/srl_nokia-snmp.yang
	- ../yang/srl/srl_nokia-ssh.yang
	- ../yang/srl/srl_nokia-static-routes.yang
	- ../yang/srl/srl_nokia-system-banner.yang
	- ../yang/srl/srl_nokia-system-info.yang
	- ../yang/srl/srl_nokia-system-name.yang
	- ../yang/srl/srl_nokia-system.yang
	- ../yang/srl/srl_nokia-tcp-udp.yang
	- ../yang/srl/srl_nokia-tls.yang
Imported modules were sourced from:
	- ../yang/ietf/...
*/
package srl_yang

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ytypes"
)


// Binary is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type Binary []byte

// YANGEmpty is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type YANGEmpty bool

var (
	SchemaTree map[string]*yang.Entry
)

func init() {
	var err error
	if SchemaTree, err = UnzipSchema(); err != nil {
		panic("schema error: " +  err.Error())
	}
}

// Schema returns the details of the generated schema.
func Schema() (*ytypes.Schema, error) {
	uzp, err := UnzipSchema()
	if err != nil {
		return nil, fmt.Errorf("cannot unzip schema, %v", err)
	}

	return &ytypes.Schema{
		Root: &Config{},
		SchemaTree: uzp,
		Unmarshal: Unmarshal,
	}, nil
}

// UnzipSchema unzips the zipped schema and returns a map of yang.Entry nodes,
// keyed by the name of the struct that the yang.Entry describes the schema for.
func UnzipSchema() (map[string]*yang.Entry, error) {
	var schemaTree map[string]*yang.Entry
	var err error
	if schemaTree, err = ygot.GzipToSchema(ySchema); err != nil {
		return nil, fmt.Errorf("could not unzip the schema; %v", err)
	}
	return schemaTree, nil
}

// Unmarshal unmarshals data, which must be RFC7951 JSON format, into
// destStruct, which must be non-nil and the correct GoStruct type. It returns
// an error if the destStruct is not found in the schema or the data cannot be
// unmarshaled. The supplied options (opts) are used to control the behaviour
// of the unmarshal function - for example, determining whether errors are
// thrown for unknown fields in the input JSON.
func Unmarshal(data []byte, destStruct ygot.GoStruct, opts ...ytypes.UnmarshalOpt) error {
	tn := reflect.TypeOf(destStruct).Elem().Name()
	schema, ok := SchemaTree[tn]
	if !ok {
		return fmt.Errorf("could not find schema for type %s", tn )
	}
	var jsonTree interface{}
	if err := json.Unmarshal([]byte(data), &jsonTree); err != nil {
		return err
	}
	return ytypes.Unmarshal(schema, destStruct, jsonTree, opts...)
}


// NewInterface creates a new entry in the Interface list of the
// Config struct. The keys of the list are populated from the input
// arguments.
func (t *Config) NewInterface(Name string) (*SrlNokiaInterfaces_Interface, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaInterfaces_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &SrlNokiaInterfaces_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// Config struct. The keys of the list are populated from the input
// arguments.
func (t *Config) NewNetworkInstance(Name string) (*SrlNokiaNetworkInstance_NetworkInstance, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaNetworkInstance_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Config) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Config"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Config) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewIpv4Filter creates a new entry in the Ipv4Filter list of the
// SrlNokiaAcl_Acl struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl) NewIpv4Filter(Name string) (*SrlNokiaAcl_Acl_Ipv4Filter, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Filter == nil {
		t.Ipv4Filter = make(map[string]*SrlNokiaAcl_Acl_Ipv4Filter)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv4Filter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv4Filter", key)
	}

	t.Ipv4Filter[key] = &SrlNokiaAcl_Acl_Ipv4Filter{
		Name: &Name,
	}

	return t.Ipv4Filter[key], nil
}

// NewIpv6Filter creates a new entry in the Ipv6Filter list of the
// SrlNokiaAcl_Acl struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl) NewIpv6Filter(Name string) (*SrlNokiaAcl_Acl_Ipv6Filter, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Filter == nil {
		t.Ipv6Filter = make(map[string]*SrlNokiaAcl_Acl_Ipv6Filter)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6Filter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6Filter", key)
	}

	t.Ipv6Filter[key] = &SrlNokiaAcl_Acl_Ipv6Filter{
		Name: &Name,
	}

	return t.Ipv6Filter[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Action_Copy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_Icmp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv4Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Action_Copy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_Icmp6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CaptureFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Accept_RateLimit) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Action_Drop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_Icmp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv4Filter_Entry_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Accept_RateLimit) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Action_Drop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_Icmp6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_CpmFilter_Ipv6Filter_Entry_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_Ipv4Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_Ipv4Filter_Entry, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_Ipv4Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_Ipv4Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_Ipv4Filter struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_Ipv4Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Action_Drop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_Icmp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics_Aggregate) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics_Aggregate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics_Aggregate) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewSubinterface creates a new entry in the Subinterface list of the
// SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics_PerInterface struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics_PerInterface) NewSubinterface(Name string) (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics_PerInterface_Subinterface, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[string]*SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics_PerInterface_Subinterface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subinterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subinterface", key)
	}

	t.Subinterface[key] = &SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics_PerInterface_Subinterface{
		Name: &Name,
	}

	return t.Subinterface[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics_PerInterface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics_PerInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics_PerInterface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics_PerInterface_Subinterface struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics_PerInterface_Subinterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics_PerInterface_Subinterface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics_PerInterface_Subinterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_Statistics_PerInterface_Subinterface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewLinecard creates a new entry in the Linecard list of the
// SrlNokiaAcl_Acl_Ipv4Filter_Entry_TcamEntries struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_TcamEntries) NewLinecard(Slot uint8) (*SrlNokiaAcl_Acl_Ipv4Filter_Entry_TcamEntries_Linecard, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Linecard == nil {
		t.Linecard = make(map[uint8]*SrlNokiaAcl_Acl_Ipv4Filter_Entry_TcamEntries_Linecard)
	}

	key := Slot

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Linecard[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Linecard", key)
	}

	t.Linecard[key] = &SrlNokiaAcl_Acl_Ipv4Filter_Entry_TcamEntries_Linecard{
		Slot: &Slot,
	}

	return t.Linecard[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_TcamEntries) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_TcamEntries"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_TcamEntries) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_Ipv4Filter_Entry_TcamEntries_Linecard struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_TcamEntries_Linecard) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Slot == nil {
		return nil, fmt.Errorf("nil value for key Slot")
	}

	return map[string]interface{}{
		"slot": *t.Slot,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_TcamEntries_Linecard) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Entry_TcamEntries_Linecard"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Entry_TcamEntries_Linecard) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv4Filter_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv4Filter_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewEntry creates a new entry in the Entry list of the
// SrlNokiaAcl_Acl_Ipv6Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) NewEntry(SequenceId uint32) (*SrlNokiaAcl_Acl_Ipv6Filter_Entry, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint32]*SrlNokiaAcl_Acl_Ipv6Filter_Entry)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaAcl_Acl_Ipv6Filter_Entry{
		SequenceId: &SequenceId,
	}

	return t.Entry[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_Ipv6Filter struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_Ipv6Filter_Entry struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Action_Drop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_DestinationPort_Range) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_Icmp6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Match_SourcePort_Range) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics_Aggregate) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics_Aggregate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics_Aggregate) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewSubinterface creates a new entry in the Subinterface list of the
// SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics_PerInterface struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics_PerInterface) NewSubinterface(Name string) (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics_PerInterface_Subinterface, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[string]*SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics_PerInterface_Subinterface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subinterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subinterface", key)
	}

	t.Subinterface[key] = &SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics_PerInterface_Subinterface{
		Name: &Name,
	}

	return t.Subinterface[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics_PerInterface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics_PerInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics_PerInterface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics_PerInterface_Subinterface struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics_PerInterface_Subinterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics_PerInterface_Subinterface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics_PerInterface_Subinterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_Statistics_PerInterface_Subinterface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewLinecard creates a new entry in the Linecard list of the
// SrlNokiaAcl_Acl_Ipv6Filter_Entry_TcamEntries struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_TcamEntries) NewLinecard(Slot uint8) (*SrlNokiaAcl_Acl_Ipv6Filter_Entry_TcamEntries_Linecard, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Linecard == nil {
		t.Linecard = make(map[uint8]*SrlNokiaAcl_Acl_Ipv6Filter_Entry_TcamEntries_Linecard)
	}

	key := Slot

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Linecard[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Linecard", key)
	}

	t.Linecard[key] = &SrlNokiaAcl_Acl_Ipv6Filter_Entry_TcamEntries_Linecard{
		Slot: &Slot,
	}

	return t.Linecard[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_TcamEntries) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_TcamEntries"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_TcamEntries) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_Ipv6Filter_Entry_TcamEntries_Linecard struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_TcamEntries_Linecard) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Slot == nil {
		return nil, fmt.Errorf("nil value for key Slot")
	}

	return map[string]interface{}{
		"slot": *t.Slot,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_TcamEntries_Linecard) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Entry_TcamEntries_Linecard"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Entry_TcamEntries_Linecard) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Ipv6Filter_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Ipv6Filter_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewPolicer creates a new entry in the Policer list of the
// SrlNokiaAcl_Acl_Policers struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_Policers) NewPolicer(Name string) (*SrlNokiaAcl_Acl_Policers_Policer, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policer == nil {
		t.Policer = make(map[string]*SrlNokiaAcl_Acl_Policers_Policer)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Policer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Policer", key)
	}

	t.Policer[key] = &SrlNokiaAcl_Acl_Policers_Policer{
		Name: &Name,
	}

	return t.Policer[key], nil
}

// NewSystemCpuPolicer creates a new entry in the SystemCpuPolicer list of the
// SrlNokiaAcl_Acl_Policers struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaAcl_Acl_Policers) NewSystemCpuPolicer(Name string) (*SrlNokiaAcl_Acl_Policers_SystemCpuPolicer, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SystemCpuPolicer == nil {
		t.SystemCpuPolicer = make(map[string]*SrlNokiaAcl_Acl_Policers_SystemCpuPolicer)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SystemCpuPolicer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SystemCpuPolicer", key)
	}

	t.SystemCpuPolicer[key] = &SrlNokiaAcl_Acl_Policers_SystemCpuPolicer{
		Name: &Name,
	}

	return t.SystemCpuPolicer[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Policers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Policers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Policers) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_Policers_Policer struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_Policers_Policer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Policers_Policer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Policers_Policer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Policers_Policer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Policers_Policer_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Policers_Policer_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Policers_Policer_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaAcl_Acl_Policers_SystemCpuPolicer struct, which is a YANG list entry.
func (t *SrlNokiaAcl_Acl_Policers_SystemCpuPolicer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Policers_SystemCpuPolicer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Policers_SystemCpuPolicer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Policers_SystemCpuPolicer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaAcl_Acl_Policers_SystemCpuPolicer_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaAcl_Acl_Policers_SystemCpuPolicer_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaAcl_Acl_Policers_SystemCpuPolicer_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaBfd_Bfd struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaBfd_Bfd) NewNetworkInstance(Name string) (*SrlNokiaBfd_Bfd_NetworkInstance, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaBfd_Bfd_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaBfd_Bfd_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// NewSubinterface creates a new entry in the Subinterface list of the
// SrlNokiaBfd_Bfd struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaBfd_Bfd) NewSubinterface(Id string) (*SrlNokiaBfd_Bfd_Subinterface, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[string]*SrlNokiaBfd_Bfd_Subinterface)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subinterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subinterface", key)
	}

	t.Subinterface[key] = &SrlNokiaBfd_Bfd_Subinterface{
		Id: &Id,
	}

	return t.Subinterface[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaBfd_Bfd"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaBfd_Bfd) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewPeer creates a new entry in the Peer list of the
// SrlNokiaBfd_Bfd_NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaBfd_Bfd_NetworkInstance) NewPeer(LocalDiscriminator uint32) (*SrlNokiaBfd_Bfd_NetworkInstance_Peer, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Peer == nil {
		t.Peer = make(map[uint32]*SrlNokiaBfd_Bfd_NetworkInstance_Peer)
	}

	key := LocalDiscriminator

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Peer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Peer", key)
	}

	t.Peer[key] = &SrlNokiaBfd_Bfd_NetworkInstance_Peer{
		LocalDiscriminator: &LocalDiscriminator,
	}

	return t.Peer[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaBfd_Bfd_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaBfd_Bfd_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaBfd_Bfd_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaBfd_Bfd_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaBfd_Bfd_NetworkInstance_Peer struct, which is a YANG list entry.
func (t *SrlNokiaBfd_Bfd_NetworkInstance_Peer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalDiscriminator == nil {
		return nil, fmt.Errorf("nil value for key LocalDiscriminator")
	}

	return map[string]interface{}{
		"local-discriminator": *t.LocalDiscriminator,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd_NetworkInstance_Peer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaBfd_Bfd_NetworkInstance_Peer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaBfd_Bfd_NetworkInstance_Peer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd_NetworkInstance_Peer_Async) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaBfd_Bfd_NetworkInstance_Peer_Async"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaBfd_Bfd_NetworkInstance_Peer_Async) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaBfd_Bfd_Subinterface struct, which is a YANG list entry.
func (t *SrlNokiaBfd_Bfd_Subinterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaBfd_Bfd_Subinterface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaBfd_Bfd_Subinterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaBfd_Bfd_Subinterface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewSubinterface creates a new entry in the Subinterface list of the
// SrlNokiaInterfaces_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface) NewSubinterface(Index uint32) (*SrlNokiaInterfaces_Interface_Subinterface, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subinterface == nil {
		t.Subinterface = make(map[uint32]*SrlNokiaInterfaces_Interface_Subinterface)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subinterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subinterface", key)
	}

	t.Subinterface[key] = &SrlNokiaInterfaces_Interface_Subinterface{
		Index: &Index,
	}

	return t.Subinterface[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_FlowControl) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_FlowControl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_FlowControl) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Ethernet_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Ethernet_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewQueue creates a new entry in the Queue list of the
// SrlNokiaInterfaces_Interface_Qos_Output struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) NewQueue(QueueId uint8) (*SrlNokiaInterfaces_Interface_Qos_Output_Queue, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Queue == nil {
		t.Queue = make(map[uint8]*SrlNokiaInterfaces_Interface_Qos_Output_Queue)
	}

	key := QueueId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Queue[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Queue", key)
	}

	t.Queue[key] = &SrlNokiaInterfaces_Interface_Qos_Output_Queue{
		QueueId: &QueueId,
	}

	return t.Queue[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos_Output"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos_Output) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Qos_Output_Queue struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) ΛListKeyMap() (map[string]interface{}, error) {
	if t.QueueId == nil {
		return nil, fmt.Errorf("nil value for key QueueId")
	}

	return map[string]interface{}{
		"queue-id": *t.QueueId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos_Output_Queue"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueScheduler) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueScheduler"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Qos_Output_Queue_QueueScheduler) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewQueue creates a new entry in the Queue list of the
// SrlNokiaInterfaces_Interface_QueueStatistics struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_QueueStatistics) NewQueue(QueueId uint8) (*SrlNokiaInterfaces_Interface_QueueStatistics_Queue, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Queue == nil {
		t.Queue = make(map[uint8]*SrlNokiaInterfaces_Interface_QueueStatistics_Queue)
	}

	key := QueueId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Queue[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Queue", key)
	}

	t.Queue[key] = &SrlNokiaInterfaces_Interface_QueueStatistics_Queue{
		QueueId: &QueueId,
	}

	return t.Queue[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_QueueStatistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_QueueStatistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_QueueStatistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewVirtualOutputQueue creates a new entry in the VirtualOutputQueue list of the
// SrlNokiaInterfaces_Interface_QueueStatistics_Queue struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_QueueStatistics_Queue) NewVirtualOutputQueue(Slot uint8) (*SrlNokiaInterfaces_Interface_QueueStatistics_Queue_VirtualOutputQueue, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VirtualOutputQueue == nil {
		t.VirtualOutputQueue = make(map[uint8]*SrlNokiaInterfaces_Interface_QueueStatistics_Queue_VirtualOutputQueue)
	}

	key := Slot

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VirtualOutputQueue[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VirtualOutputQueue", key)
	}

	t.VirtualOutputQueue[key] = &SrlNokiaInterfaces_Interface_QueueStatistics_Queue_VirtualOutputQueue{
		Slot: &Slot,
	}

	return t.VirtualOutputQueue[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_QueueStatistics_Queue struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_QueueStatistics_Queue) ΛListKeyMap() (map[string]interface{}, error) {
	if t.QueueId == nil {
		return nil, fmt.Errorf("nil value for key QueueId")
	}

	return map[string]interface{}{
		"queue-id": *t.QueueId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_QueueStatistics_Queue) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_QueueStatistics_Queue"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_QueueStatistics_Queue) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_QueueStatistics_Queue_VirtualOutputQueue struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_QueueStatistics_Queue_VirtualOutputQueue) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Slot == nil {
		return nil, fmt.Errorf("nil value for key Slot")
	}

	return map[string]interface{}{
		"slot": *t.Slot,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_QueueStatistics_Queue_VirtualOutputQueue) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_QueueStatistics_Queue_VirtualOutputQueue"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_QueueStatistics_Queue_VirtualOutputQueue) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Sflow) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Sflow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Sflow) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Acl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Acl_Input"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Input) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Acl_Output"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Acl_Output) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewAddress creates a new entry in the Address list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv4 struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) NewAddress(IpPrefix string) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address)
	}

	key := IpPrefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address{
		IpPrefix: &IpPrefix,
	}

	return t.Address[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	return map[string]interface{}{
		"ip-prefix": *t.IpPrefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Address) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewNeighbor creates a new entry in the Neighbor list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) NewNeighbor(Ipv4Address string) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor)
	}

	key := Ipv4Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor{
		Ipv4Address: &Ipv4Address,
	}

	return t.Neighbor[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ipv4Address == nil {
		return nil, fmt.Errorf("nil value for key Ipv4Address")
	}

	return map[string]interface{}{
		"ipv4-address": *t.Ipv4Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_Arp_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv4_DhcpClient_TraceOptions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewAddress creates a new entry in the Address list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv6 struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) NewAddress(IpPrefix string) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Address == nil {
		t.Address = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address)
	}

	key := IpPrefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Address[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Address", key)
	}

	t.Address[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address{
		IpPrefix: &IpPrefix,
	}

	return t.Address[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	return map[string]interface{}{
		"ip-prefix": *t.IpPrefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_Address) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_DhcpClient_TraceOptions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewNeighbor creates a new entry in the Neighbor list of the
// SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) NewNeighbor(Ipv6Address string) (*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor)
	}

	key := Ipv6Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor{
		Ipv6Address: &Ipv6Address,
	}

	return t.Neighbor[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ipv6Address == nil {
		return nil, fmt.Errorf("nil value for key Ipv6Address")
	}

	return map[string]interface{}{
		"ipv6-address": *t.Ipv6Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Ipv6_NeighborDiscovery_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Qos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Qos_Input"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Input_Classifiers) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Qos_Output"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Qos_Output_RewriteRules) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Vlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Subinterface_Vlan_Encap_SingleTagged) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_TrafficRate) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_TrafficRate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_TrafficRate) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewChannel creates a new entry in the Channel list of the
// SrlNokiaInterfaces_Interface_Transceiver struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaInterfaces_Interface_Transceiver) NewChannel(Index uint8) (*SrlNokiaInterfaces_Interface_Transceiver_Channel, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Channel == nil {
		t.Channel = make(map[uint8]*SrlNokiaInterfaces_Interface_Transceiver_Channel)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Channel[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Channel", key)
	}

	t.Channel[key] = &SrlNokiaInterfaces_Interface_Transceiver_Channel{
		Index: &Index,
	}

	return t.Channel[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Transceiver) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Transceiver"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Transceiver) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaInterfaces_Interface_Transceiver_Channel struct, which is a YANG list entry.
func (t *SrlNokiaInterfaces_Interface_Transceiver_Channel) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Transceiver_Channel) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Transceiver_Channel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Transceiver_Channel) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Transceiver_Channel_InputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Transceiver_Channel_InputPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Transceiver_Channel_InputPower) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Transceiver_Channel_LaserBiasCurrent) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Transceiver_Channel_LaserBiasCurrent"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Transceiver_Channel_LaserBiasCurrent) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Transceiver_Channel_OutputPower) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Transceiver_Channel_OutputPower"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Transceiver_Channel_OutputPower) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Transceiver_Temperature) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Transceiver_Temperature"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Transceiver_Temperature) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaInterfaces_Interface_Transceiver_Voltage) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaInterfaces_Interface_Transceiver_Voltage"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaInterfaces_Interface_Transceiver_Voltage) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewAft creates a new entry in the Aft list of the
// SrlNokiaNetworkInstance_NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance) NewAft(AddressFamily string) (*SrlNokiaNetworkInstance_NetworkInstance_Aft, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Aft == nil {
		t.Aft = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_Aft)
	}

	key := AddressFamily

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Aft[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Aft", key)
	}

	t.Aft[key] = &SrlNokiaNetworkInstance_NetworkInstance_Aft{
		AddressFamily: &AddressFamily,
	}

	return t.Aft[key], nil
}

// NewInterface creates a new entry in the Interface list of the
// SrlNokiaNetworkInstance_NetworkInstance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance) NewInterface(Name string) (*SrlNokiaNetworkInstance_NetworkInstance_Interface, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &SrlNokiaNetworkInstance_NetworkInstance_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Aft struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft) ΛListKeyMap() (map[string]interface{}, error) {
	if t.AddressFamily == nil {
		return nil, fmt.Errorf("nil value for key AddressFamily")
	}

	return map[string]interface{}{
		"address-family": *t.AddressFamily,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Aft"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewEntry creates a new entry in the Entry list of the
// SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries) NewEntry(Index uint64) (*SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[uint64]*SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry{
		Index: &Index,
	}

	return t.Entry[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewNextHop creates a new entry in the NextHop list of the
// SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry) NewNextHop(Index uint64) (*SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry_NextHop, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry_Match) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry_Match_State) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry_Match_State"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry_Match_State) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry_NextHop struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry_NextHop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry_NextHop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry_NextHop_State) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry_NextHop_State"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Aft_Entries_Entry_NextHop_State) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewRoute creates a new entry in the Route list of the
// SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes) NewRoute(Prefix string) (*SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Route == nil {
		t.Route = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Route[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Route", key)
	}

	t.Route[key] = &SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route{
		Prefix: &Prefix,
	}

	return t.Route[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Aggregator) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_AggregateRoutes_Route_Communities) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewAttrSet creates a new entry in the AttrSet list of the
// SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets) NewAttrSet(AttrSetType E_SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_AttrSetType, Index uint64) (*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AttrSet == nil {
		t.AttrSet = make(map[SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_Key]*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet)
	}

	key := SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_Key{
		AttrSetType: AttrSetType,
		Index: Index,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AttrSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AttrSet", key)
	}

	t.AttrSet[key] = &SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet{
		AttrSetType: AttrSetType,
		Index: &Index,
	}

	return t.AttrSet[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet) ΛListKeyMap() (map[string]interface{}, error) {

	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"attr-set-type": t.AttrSetType,
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_Aggregator) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_Aggregator"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_Aggregator) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewSegment creates a new entry in the Segment list of the
// SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_AsPath struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_AsPath) NewSegment(AsPathIndex uint32) (*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_AsPath_Segment, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Segment == nil {
		t.Segment = make(map[uint32]*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_AsPath_Segment)
	}

	key := AsPathIndex

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Segment[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Segment", key)
	}

	t.Segment[key] = &SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_AsPath_Segment{
		AsPathIndex: &AsPathIndex,
	}

	return t.Segment[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_AsPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_AsPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_AsPath) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_AsPath_Segment struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_AsPath_Segment) ΛListKeyMap() (map[string]interface{}, error) {
	if t.AsPathIndex == nil {
		return nil, fmt.Errorf("nil value for key AsPathIndex")
	}

	return map[string]interface{}{
		"as-path-index": *t.AsPathIndex,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_AsPath_Segment) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_AsPath_Segment"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_AsPath_Segment) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_Communities) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_Communities"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_Communities) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewUnknownAttribute creates a new entry in the UnknownAttribute list of the
// SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_UnknownAttributes struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_UnknownAttributes) NewUnknownAttribute(UnknownAttrIndex uint32) (*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_UnknownAttributes_UnknownAttribute, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UnknownAttribute == nil {
		t.UnknownAttribute = make(map[uint32]*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_UnknownAttributes_UnknownAttribute)
	}

	key := UnknownAttrIndex

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UnknownAttribute[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UnknownAttribute", key)
	}

	t.UnknownAttribute[key] = &SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_UnknownAttributes_UnknownAttribute{
		UnknownAttrIndex: &UnknownAttrIndex,
	}

	return t.UnknownAttribute[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_UnknownAttributes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_UnknownAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_UnknownAttributes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_UnknownAttributes_UnknownAttribute struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_UnknownAttributes_UnknownAttribute) ΛListKeyMap() (map[string]interface{}, error) {
	if t.UnknownAttrIndex == nil {
		return nil, fmt.Errorf("nil value for key UnknownAttrIndex")
	}

	return map[string]interface{}{
		"unknown-attr-index": *t.UnknownAttrIndex,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_UnknownAttributes_UnknownAttribute) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_UnknownAttributes_UnknownAttribute"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_AttrSets_AttrSet_UnknownAttributes_UnknownAttribute) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewRoutes creates a new entry in the Routes list of the
// SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib) NewRoutes(Prefix string, Neighbor string, OriginProtocol E_SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib_Routes_OriginProtocol) (*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib_Routes, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Routes == nil {
		t.Routes = make(map[SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib_Routes_Key]*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib_Routes)
	}

	key := SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib_Routes_Key{
		Prefix: Prefix,
		Neighbor: Neighbor,
		OriginProtocol: OriginProtocol,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Routes[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Routes", key)
	}

	t.Routes[key] = &SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib_Routes{
		Prefix: &Prefix,
		Neighbor: &Neighbor,
		OriginProtocol: OriginProtocol,
	}

	return t.Routes[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib_Routes struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib_Routes) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Neighbor == nil {
		return nil, fmt.Errorf("nil value for key Neighbor")
	}


	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"neighbor": *t.Neighbor,
		"origin-protocol": t.OriginProtocol,
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib_Routes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib_Routes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib_Routes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib_Routes_InvalidReason) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib_Routes_InvalidReason"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_LocalRib_Routes_InvalidReason) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewRoutes creates a new entry in the Routes list of the
// SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost) NewRoutes(Prefix string, Neighbor string) (*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost_Routes, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Routes == nil {
		t.Routes = make(map[SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost_Routes_Key]*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost_Routes)
	}

	key := SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost_Routes_Key{
		Prefix: Prefix,
		Neighbor: Neighbor,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Routes[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Routes", key)
	}

	t.Routes[key] = &SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost_Routes{
		Prefix: &Prefix,
		Neighbor: &Neighbor,
	}

	return t.Routes[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost_Routes struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost_Routes) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Neighbor == nil {
		return nil, fmt.Errorf("nil value for key Neighbor")
	}

	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"neighbor": *t.Neighbor,
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost_Routes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost_Routes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost_Routes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost_Routes_InvalidReason) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost_Routes_InvalidReason"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPost_Routes_InvalidReason) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewRoutes creates a new entry in the Routes list of the
// SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPre struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPre) NewRoutes(Prefix string, Neighbor string) (*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPre_Routes, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Routes == nil {
		t.Routes = make(map[SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPre_Routes_Key]*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPre_Routes)
	}

	key := SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPre_Routes_Key{
		Prefix: Prefix,
		Neighbor: Neighbor,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Routes[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Routes", key)
	}

	t.Routes[key] = &SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPre_Routes{
		Prefix: &Prefix,
		Neighbor: &Neighbor,
	}

	return t.Routes[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPre) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPre"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPre) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPre_Routes struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPre_Routes) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Neighbor == nil {
		return nil, fmt.Errorf("nil value for key Neighbor")
	}

	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"neighbor": *t.Neighbor,
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPre_Routes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPre_Routes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibInPre_Routes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewRoutes creates a new entry in the Routes list of the
// SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibOutPost struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibOutPost) NewRoutes(Prefix string, Neighbor string) (*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibOutPost_Routes, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Routes == nil {
		t.Routes = make(map[SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibOutPost_Routes_Key]*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibOutPost_Routes)
	}

	key := SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibOutPost_Routes_Key{
		Prefix: Prefix,
		Neighbor: Neighbor,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Routes[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Routes", key)
	}

	t.Routes[key] = &SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibOutPost_Routes{
		Prefix: &Prefix,
		Neighbor: &Neighbor,
	}

	return t.Routes[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibOutPost) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibOutPost"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibOutPost) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibOutPost_Routes struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibOutPost_Routes) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Neighbor == nil {
		return nil, fmt.Errorf("nil value for key Neighbor")
	}

	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"neighbor": *t.Neighbor,
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibOutPost_Routes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibOutPost_Routes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv4Unicast_RibInOut_RibOutPost_Routes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewRoutes creates a new entry in the Routes list of the
// SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib) NewRoutes(Prefix string, Neighbor string, OriginProtocol E_SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib_Routes_OriginProtocol) (*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib_Routes, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Routes == nil {
		t.Routes = make(map[SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib_Routes_Key]*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib_Routes)
	}

	key := SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib_Routes_Key{
		Prefix: Prefix,
		Neighbor: Neighbor,
		OriginProtocol: OriginProtocol,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Routes[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Routes", key)
	}

	t.Routes[key] = &SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib_Routes{
		Prefix: &Prefix,
		Neighbor: &Neighbor,
		OriginProtocol: OriginProtocol,
	}

	return t.Routes[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib_Routes struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib_Routes) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Neighbor == nil {
		return nil, fmt.Errorf("nil value for key Neighbor")
	}


	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"neighbor": *t.Neighbor,
		"origin-protocol": t.OriginProtocol,
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib_Routes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib_Routes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib_Routes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib_Routes_InvalidReason) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib_Routes_InvalidReason"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_LocalRib_Routes_InvalidReason) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewRoutes creates a new entry in the Routes list of the
// SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost) NewRoutes(Prefix string, Neighbor string) (*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost_Routes, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Routes == nil {
		t.Routes = make(map[SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost_Routes_Key]*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost_Routes)
	}

	key := SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost_Routes_Key{
		Prefix: Prefix,
		Neighbor: Neighbor,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Routes[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Routes", key)
	}

	t.Routes[key] = &SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost_Routes{
		Prefix: &Prefix,
		Neighbor: &Neighbor,
	}

	return t.Routes[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost_Routes struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost_Routes) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Neighbor == nil {
		return nil, fmt.Errorf("nil value for key Neighbor")
	}

	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"neighbor": *t.Neighbor,
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost_Routes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost_Routes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost_Routes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost_Routes_InvalidReason) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost_Routes_InvalidReason"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPost_Routes_InvalidReason) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewRoutes creates a new entry in the Routes list of the
// SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPre struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPre) NewRoutes(Prefix string, Neighbor string) (*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPre_Routes, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Routes == nil {
		t.Routes = make(map[SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPre_Routes_Key]*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPre_Routes)
	}

	key := SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPre_Routes_Key{
		Prefix: Prefix,
		Neighbor: Neighbor,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Routes[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Routes", key)
	}

	t.Routes[key] = &SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPre_Routes{
		Prefix: &Prefix,
		Neighbor: &Neighbor,
	}

	return t.Routes[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPre) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPre"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPre) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPre_Routes struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPre_Routes) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Neighbor == nil {
		return nil, fmt.Errorf("nil value for key Neighbor")
	}

	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"neighbor": *t.Neighbor,
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPre_Routes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPre_Routes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibInPre_Routes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewRoutes creates a new entry in the Routes list of the
// SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibOutPost struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibOutPost) NewRoutes(Prefix string, Neighbor string) (*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibOutPost_Routes, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Routes == nil {
		t.Routes = make(map[SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibOutPost_Routes_Key]*SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibOutPost_Routes)
	}

	key := SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibOutPost_Routes_Key{
		Prefix: Prefix,
		Neighbor: Neighbor,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Routes[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Routes", key)
	}

	t.Routes[key] = &SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibOutPost_Routes{
		Prefix: &Prefix,
		Neighbor: &Neighbor,
	}

	return t.Routes[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibOutPost) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibOutPost"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibOutPost) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibOutPost_Routes struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibOutPost_Routes) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Neighbor == nil {
		return nil, fmt.Errorf("nil value for key Neighbor")
	}

	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"neighbor": *t.Neighbor,
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibOutPost_Routes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibOutPost_Routes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_BgpRib_Ipv6Unicast_RibInOut_RibOutPost_Routes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Icmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp6) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Icmp6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp6) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewType creates a new entry in the Type list of the
// SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics) NewType(Name E_SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics_Type_Name) (*SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics_Type, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Type == nil {
		t.Type = make(map[E_SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics_Type_Name]*SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics_Type)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Type[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Type", key)
	}

	t.Type[key] = &SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics_Type{
		Name: Name,
	}

	return t.Type[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics_Total) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics_Total"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics_Total) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics_Type struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics_Type) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics_Type) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics_Type"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp6_Statistics_Type) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewType creates a new entry in the Type list of the
// SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics) NewType(Name E_SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics_Type_Name) (*SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics_Type, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Type == nil {
		t.Type = make(map[E_SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics_Type_Name]*SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics_Type)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Type[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Type", key)
	}

	t.Type[key] = &SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics_Type{
		Name: Name,
	}

	return t.Type[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics_Total) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics_Total"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics_Total) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics_Type struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics_Type) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics_Type) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics_Type"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Icmp_Statistics_Type) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Interface struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_IpForwarding) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_IpForwarding"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_IpForwarding) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewResilientHashPrefix creates a new entry in the ResilientHashPrefix list of the
// SrlNokiaNetworkInstance_NetworkInstance_IpLoadBalancing struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_IpLoadBalancing) NewResilientHashPrefix(IpPrefix string) (*SrlNokiaNetworkInstance_NetworkInstance_IpLoadBalancing_ResilientHashPrefix, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ResilientHashPrefix == nil {
		t.ResilientHashPrefix = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_IpLoadBalancing_ResilientHashPrefix)
	}

	key := IpPrefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ResilientHashPrefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ResilientHashPrefix", key)
	}

	t.ResilientHashPrefix[key] = &SrlNokiaNetworkInstance_NetworkInstance_IpLoadBalancing_ResilientHashPrefix{
		IpPrefix: &IpPrefix,
	}

	return t.ResilientHashPrefix[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_IpLoadBalancing) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_IpLoadBalancing"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_IpLoadBalancing) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_IpLoadBalancing_ResilientHashPrefix struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_IpLoadBalancing_ResilientHashPrefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	return map[string]interface{}{
		"ip-prefix": *t.IpPrefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_IpLoadBalancing_ResilientHashPrefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_IpLoadBalancing_ResilientHashPrefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_IpLoadBalancing_ResilientHashPrefix) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewStaticMplsEntry creates a new entry in the StaticMplsEntry list of the
// SrlNokiaNetworkInstance_NetworkInstance_Mpls struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Mpls) NewStaticMplsEntry(TopLabel SrlNokiaNetworkInstance_NetworkInstance_Mpls_StaticMplsEntry_TopLabel_Union) (*SrlNokiaNetworkInstance_NetworkInstance_Mpls_StaticMplsEntry, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticMplsEntry == nil {
		t.StaticMplsEntry = make(map[SrlNokiaNetworkInstance_NetworkInstance_Mpls_StaticMplsEntry_TopLabel_Union]*SrlNokiaNetworkInstance_NetworkInstance_Mpls_StaticMplsEntry)
	}

	key := TopLabel

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.StaticMplsEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list StaticMplsEntry", key)
	}

	t.StaticMplsEntry[key] = &SrlNokiaNetworkInstance_NetworkInstance_Mpls_StaticMplsEntry{
		TopLabel: TopLabel,
	}

	return t.StaticMplsEntry[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Mpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Mpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Mpls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Mpls_StaticMplsEntry struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Mpls_StaticMplsEntry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"top-label": t.TopLabel,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Mpls_StaticMplsEntry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Mpls_StaticMplsEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Mpls_StaticMplsEntry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Mtu) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Mtu"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Mtu) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewGroup creates a new entry in the Group list of the
// SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups) NewGroup(Name string) (*SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Group[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Group", key)
	}

	t.Group[key] = &SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group{
		Name: &Name,
	}

	return t.Group[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewNexthop creates a new entry in the Nexthop list of the
// SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group) NewNexthop(Index uint16) (*SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group_Nexthop, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Nexthop == nil {
		t.Nexthop = make(map[uint16]*SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group_Nexthop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Nexthop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Nexthop", key)
	}

	t.Nexthop[key] = &SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group_Nexthop{
		Index: &Index,
	}

	return t.Nexthop[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group_Blackhole) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group_Blackhole"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group_Blackhole) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group_Nexthop struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group_Nexthop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group_Nexthop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group_Nexthop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_NextHopGroups_Group_Nexthop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewGroup creates a new entry in the Group list of the
// SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp) NewGroup(GroupName string) (*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group)
	}

	key := GroupName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Group[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Group", key)
	}

	t.Group[key] = &SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group{
		GroupName: &GroupName,
	}

	return t.Group[key], nil
}

// NewNeighbor creates a new entry in the Neighbor list of the
// SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp) NewNeighbor(PeerAddress string) (*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor)
	}

	key := PeerAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor{
		PeerAddress: &PeerAddress,
	}

	return t.Neighbor[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_AsPathOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_AsPathOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_AsPathOptions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Convergence) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Convergence"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Convergence) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewMatch creates a new entry in the Match list of the
// SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors_Accept struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors_Accept) NewMatch(Prefix string, GroupIdRange string) (*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors_Accept_Match, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Match == nil {
		t.Match = make(map[SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors_Accept_Match_Key]*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors_Accept_Match)
	}

	key := SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors_Accept_Match_Key{
		Prefix: Prefix,
		GroupIdRange: GroupIdRange,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Match[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Match", key)
	}

	t.Match[key] = &SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors_Accept_Match{
		Prefix: &Prefix,
		GroupIdRange: &GroupIdRange,
	}

	return t.Match[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors_Accept) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors_Accept) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors_Accept_Match struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors_Accept_Match) ΛListKeyMap() (map[string]interface{}, error) {
	if t.GroupIdRange == nil {
		return nil, fmt.Errorf("nil value for key GroupIdRange")
	}

	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"group-id-range": *t.GroupIdRange,
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors_Accept_Match) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors_Accept_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_DynamicNeighbors_Accept_Match) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_EbgpDefaultPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_EbgpDefaultPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_EbgpDefaultPolicy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_FailureDetection) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_FailureDetection"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_FailureDetection) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewLocalAs creates a new entry in the LocalAs list of the
// SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group) NewLocalAs(AsNumber uint32) (*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_LocalAs, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LocalAs == nil {
		t.LocalAs = make(map[uint32]*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_LocalAs)
	}

	key := AsNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LocalAs[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LocalAs", key)
	}

	t.LocalAs[key] = &SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_LocalAs{
		AsNumber: &AsNumber,
	}

	return t.LocalAs[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group) ΛListKeyMap() (map[string]interface{}, error) {
	if t.GroupName == nil {
		return nil, fmt.Errorf("nil value for key GroupName")
	}

	return map[string]interface{}{
		"group-name": *t.GroupName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_AsPathOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_AsPathOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_AsPathOptions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_FailureDetection) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_FailureDetection"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_FailureDetection) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Ipv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Ipv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Ipv4Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Ipv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Ipv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Ipv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Ipv6Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Ipv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_LocalAs struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_LocalAs) ΛListKeyMap() (map[string]interface{}, error) {
	if t.AsNumber == nil {
		return nil, fmt.Errorf("nil value for key AsNumber")
	}

	return map[string]interface{}{
		"as-number": *t.AsNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_LocalAs) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_LocalAs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_LocalAs) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_SendCommunity) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_SendCommunity"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_SendCommunity) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_SendDefaultRoute) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_SendDefaultRoute"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_SendDefaultRoute) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Timers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Timers) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewFlag creates a new entry in the Flag list of the
// SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions) NewFlag(Name E_SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions_Flag_Name) (*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions_Flag, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Flag == nil {
		t.Flag = make(map[E_SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions_Flag_Name]*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions_Flag)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Flag[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Flag", key)
	}

	t.Flag[key] = &SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions_Flag{
		Name: Name,
	}

	return t.Flag[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions_Flag struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions_Flag) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions_Flag) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions_Flag"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions_Flag) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Transport"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_Transport) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv4Unicast_Convergence) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv4Unicast_Convergence"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv4Unicast_Convergence) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv4Unicast_Multipath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv4Unicast_Multipath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv4Unicast_Multipath) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv6Unicast_Convergence) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv6Unicast_Convergence"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv6Unicast_Convergence) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv6Unicast_Multipath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv6Unicast_Multipath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Ipv6Unicast_Multipath) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewLocalAs creates a new entry in the LocalAs list of the
// SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor) NewLocalAs(AsNumber uint32) (*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_LocalAs, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LocalAs == nil {
		t.LocalAs = make(map[uint32]*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_LocalAs)
	}

	key := AsNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LocalAs[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LocalAs", key)
	}

	t.LocalAs[key] = &SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_LocalAs{
		AsNumber: &AsNumber,
	}

	return t.LocalAs[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PeerAddress == nil {
		return nil, fmt.Errorf("nil value for key PeerAddress")
	}

	return map[string]interface{}{
		"peer-address": *t.PeerAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_AsPathOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_AsPathOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_AsPathOptions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_FailureDetection) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_FailureDetection"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_FailureDetection) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewAfiSafi creates a new entry in the AfiSafi list of the
// SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart_NeighborCapability struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart_NeighborCapability) NewAfiSafi(Name E_SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart_NeighborCapability_AfiSafi_Name) (*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart_NeighborCapability_AfiSafi, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AfiSafi == nil {
		t.AfiSafi = make(map[E_SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart_NeighborCapability_AfiSafi_Name]*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart_NeighborCapability_AfiSafi)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AfiSafi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AfiSafi", key)
	}

	t.AfiSafi[key] = &SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart_NeighborCapability_AfiSafi{
		Name: Name,
	}

	return t.AfiSafi[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart_NeighborCapability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart_NeighborCapability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart_NeighborCapability) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart_NeighborCapability_AfiSafi struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart_NeighborCapability_AfiSafi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart_NeighborCapability_AfiSafi) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart_NeighborCapability_AfiSafi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_GracefulRestart_NeighborCapability_AfiSafi) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Ipv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Ipv4Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Ipv4Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Ipv4Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Ipv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Ipv6Unicast_PrefixLimit) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Ipv6Unicast_PrefixLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Ipv6Unicast_PrefixLimit) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_LocalAs struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_LocalAs) ΛListKeyMap() (map[string]interface{}, error) {
	if t.AsNumber == nil {
		return nil, fmt.Errorf("nil value for key AsNumber")
	}

	return map[string]interface{}{
		"as-number": *t.AsNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_LocalAs) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_LocalAs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_LocalAs) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_ReceivedMessages) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_ReceivedMessages"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_ReceivedMessages) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_SendCommunity) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_SendCommunity"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_SendCommunity) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_SendDefaultRoute) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_SendDefaultRoute"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_SendDefaultRoute) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_SentMessages) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_SentMessages"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_SentMessages) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Timers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Timers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Timers) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewFlag creates a new entry in the Flag list of the
// SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_TraceOptions struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_TraceOptions) NewFlag(Name E_SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions_Flag_Name) (*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_TraceOptions_Flag, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Flag == nil {
		t.Flag = make(map[E_SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions_Flag_Name]*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_TraceOptions_Flag)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Flag[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Flag", key)
	}

	t.Flag[key] = &SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_TraceOptions_Flag{
		Name: Name,
	}

	return t.Flag[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_TraceOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_TraceOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_TraceOptions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_TraceOptions_Flag struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_TraceOptions_Flag) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_TraceOptions_Flag) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_TraceOptions_Flag"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_TraceOptions_Flag) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Transport"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Neighbor_Transport) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Preference) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Preference"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Preference) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_RouteAdvertisement) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_RouteAdvertisement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_RouteAdvertisement) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_SendCommunity) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_SendCommunity"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_SendCommunity) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewFlag creates a new entry in the Flag list of the
// SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_TraceOptions struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_TraceOptions) NewFlag(Name E_SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions_Flag_Name) (*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_TraceOptions_Flag, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Flag == nil {
		t.Flag = make(map[E_SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Group_TraceOptions_Flag_Name]*SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_TraceOptions_Flag)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Flag[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Flag", key)
	}

	t.Flag[key] = &SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_TraceOptions_Flag{
		Name: Name,
	}

	return t.Flag[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_TraceOptions) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_TraceOptions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_TraceOptions) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_TraceOptions_Flag struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_TraceOptions_Flag) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_TraceOptions_Flag) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_TraceOptions_Flag"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_TraceOptions_Flag) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Transport) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Transport"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Bgp_Transport) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Linux) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Protocols_Linux"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Protocols_Linux) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewNextHop creates a new entry in the NextHop list of the
// SrlNokiaNetworkInstance_NetworkInstance_RouteTable struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable) NewNextHop(Index uint64) (*SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHop, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint64]*SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHop)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHop{
		Index: &Index,
	}

	return t.NextHop[key], nil
}

// NewNextHopGroup creates a new entry in the NextHopGroup list of the
// SrlNokiaNetworkInstance_NetworkInstance_RouteTable struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable) NewNextHopGroup(Index uint64) (*SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHopGroup == nil {
		t.NextHopGroup = make(map[uint64]*SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHopGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHopGroup", key)
	}

	t.NextHopGroup[key] = &SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup{
		Index: &Index,
	}

	return t.NextHopGroup[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_RouteTable"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewRoute creates a new entry in the Route list of the
// SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast) NewRoute(Ipv4Prefix string, Id uint16) (*SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast_Route, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Route == nil {
		t.Route = make(map[SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast_Route_Key]*SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast_Route)
	}

	key := SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast_Route_Key{
		Ipv4Prefix: Ipv4Prefix,
		Id: Id,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Route[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Route", key)
	}

	t.Route[key] = &SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast_Route{
		Ipv4Prefix: &Ipv4Prefix,
		Id: &Id,
	}

	return t.Route[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast_Route struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast_Route) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	if t.Ipv4Prefix == nil {
		return nil, fmt.Errorf("nil value for key Ipv4Prefix")
	}

	return map[string]interface{}{
		"id": *t.Id,
		"ipv4-prefix": *t.Ipv4Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast_Route) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast_Route"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast_Route) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast_Route_FibProgramming) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast_Route_FibProgramming"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast_Route_FibProgramming) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv4Unicast_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewRoute creates a new entry in the Route list of the
// SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast) NewRoute(Ipv6Prefix string, Id uint16) (*SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast_Route, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Route == nil {
		t.Route = make(map[SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast_Route_Key]*SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast_Route)
	}

	key := SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast_Route_Key{
		Ipv6Prefix: Ipv6Prefix,
		Id: Id,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Route[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Route", key)
	}

	t.Route[key] = &SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast_Route{
		Ipv6Prefix: &Ipv6Prefix,
		Id: &Id,
	}

	return t.Route[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast_Route struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast_Route) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	if t.Ipv6Prefix == nil {
		return nil, fmt.Errorf("nil value for key Ipv6Prefix")
	}

	return map[string]interface{}{
		"id": *t.Id,
		"ipv6-prefix": *t.Ipv6Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast_Route) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast_Route"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast_Route) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast_Route_FibProgramming) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast_Route_FibProgramming"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast_Route_FibProgramming) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Ipv6Unicast_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewRoute creates a new entry in the Route list of the
// SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls) NewRoute(Label SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls_Route_Label_Union, Id uint16) (*SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls_Route, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Route == nil {
		t.Route = make(map[SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls_Route_Key]*SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls_Route)
	}

	key := SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls_Route_Key{
		Label: Label,
		Id: Id,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Route[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Route", key)
	}

	t.Route[key] = &SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls_Route{
		Label: Label,
		Id: &Id,
	}

	return t.Route[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls_Route struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls_Route) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}


	return map[string]interface{}{
		"id": *t.Id,
		"label": t.Label,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls_Route) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls_Route"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls_Route) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_Mpls_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHop struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewNextHop creates a new entry in the NextHop list of the
// SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup) NewNextHop(Id uint16) (*SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup_NextHop, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NextHop == nil {
		t.NextHop = make(map[uint16]*SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup_NextHop)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NextHop[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NextHop", key)
	}

	t.NextHop[key] = &SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup_NextHop{
		Id: &Id,
	}

	return t.NextHop[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Index == nil {
		return nil, fmt.Errorf("nil value for key Index")
	}

	return map[string]interface{}{
		"index": *t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup_NextHop struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup_NextHop) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup_NextHop) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHopGroup_NextHop) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHop_ResolvingRoute) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHop_ResolvingRoute"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_RouteTable_NextHop_ResolvingRoute) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewRoute creates a new entry in the Route list of the
// SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes) NewRoute(Prefix string) (*SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Route == nil {
		t.Route = make(map[string]*SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Route[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Route", key)
	}

	t.Route[key] = &SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route{
		Prefix: &Prefix,
	}

	return t.Route[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_StaticRoutes_Route) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewConnection creates a new entry in the Connection list of the
// SrlNokiaNetworkInstance_NetworkInstance_Tcp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Tcp) NewConnection(LocalAddress string, LocalPort uint16, RemoteAddress string, RemotePort uint16) (*SrlNokiaNetworkInstance_NetworkInstance_Tcp_Connection, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Connection == nil {
		t.Connection = make(map[SrlNokiaNetworkInstance_NetworkInstance_Tcp_Connection_Key]*SrlNokiaNetworkInstance_NetworkInstance_Tcp_Connection)
	}

	key := SrlNokiaNetworkInstance_NetworkInstance_Tcp_Connection_Key{
		LocalAddress: LocalAddress,
		LocalPort: LocalPort,
		RemoteAddress: RemoteAddress,
		RemotePort: RemotePort,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Connection[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Connection", key)
	}

	t.Connection[key] = &SrlNokiaNetworkInstance_NetworkInstance_Tcp_Connection{
		LocalAddress: &LocalAddress,
		LocalPort: &LocalPort,
		RemoteAddress: &RemoteAddress,
		RemotePort: &RemotePort,
	}

	return t.Connection[key], nil
}

// NewListeningApplication creates a new entry in the ListeningApplication list of the
// SrlNokiaNetworkInstance_NetworkInstance_Tcp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Tcp) NewListeningApplication(LocalAddress string, LocalPort uint16) (*SrlNokiaNetworkInstance_NetworkInstance_Tcp_ListeningApplication, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ListeningApplication == nil {
		t.ListeningApplication = make(map[SrlNokiaNetworkInstance_NetworkInstance_Tcp_ListeningApplication_Key]*SrlNokiaNetworkInstance_NetworkInstance_Tcp_ListeningApplication)
	}

	key := SrlNokiaNetworkInstance_NetworkInstance_Tcp_ListeningApplication_Key{
		LocalAddress: LocalAddress,
		LocalPort: LocalPort,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ListeningApplication[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ListeningApplication", key)
	}

	t.ListeningApplication[key] = &SrlNokiaNetworkInstance_NetworkInstance_Tcp_ListeningApplication{
		LocalAddress: &LocalAddress,
		LocalPort: &LocalPort,
	}

	return t.ListeningApplication[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Tcp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Tcp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Tcp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Tcp_Connection struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Tcp_Connection) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalAddress == nil {
		return nil, fmt.Errorf("nil value for key LocalAddress")
	}

	if t.LocalPort == nil {
		return nil, fmt.Errorf("nil value for key LocalPort")
	}

	if t.RemoteAddress == nil {
		return nil, fmt.Errorf("nil value for key RemoteAddress")
	}

	if t.RemotePort == nil {
		return nil, fmt.Errorf("nil value for key RemotePort")
	}

	return map[string]interface{}{
		"local-address": *t.LocalAddress,
		"local-port": *t.LocalPort,
		"remote-address": *t.RemoteAddress,
		"remote-port": *t.RemotePort,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Tcp_Connection) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Tcp_Connection"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Tcp_Connection) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Tcp_ListeningApplication struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Tcp_ListeningApplication) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalAddress == nil {
		return nil, fmt.Errorf("nil value for key LocalAddress")
	}

	if t.LocalPort == nil {
		return nil, fmt.Errorf("nil value for key LocalPort")
	}

	return map[string]interface{}{
		"local-address": *t.LocalAddress,
		"local-port": *t.LocalPort,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Tcp_ListeningApplication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Tcp_ListeningApplication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Tcp_ListeningApplication) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Tcp_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Tcp_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Tcp_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewListeningApplication creates a new entry in the ListeningApplication list of the
// SrlNokiaNetworkInstance_NetworkInstance_Udp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Udp) NewListeningApplication(LocalAddress string, LocalPort uint16) (*SrlNokiaNetworkInstance_NetworkInstance_Udp_ListeningApplication, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ListeningApplication == nil {
		t.ListeningApplication = make(map[SrlNokiaNetworkInstance_NetworkInstance_Udp_ListeningApplication_Key]*SrlNokiaNetworkInstance_NetworkInstance_Udp_ListeningApplication)
	}

	key := SrlNokiaNetworkInstance_NetworkInstance_Udp_ListeningApplication_Key{
		LocalAddress: LocalAddress,
		LocalPort: LocalPort,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ListeningApplication[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ListeningApplication", key)
	}

	t.ListeningApplication[key] = &SrlNokiaNetworkInstance_NetworkInstance_Udp_ListeningApplication{
		LocalAddress: &LocalAddress,
		LocalPort: &LocalPort,
	}

	return t.ListeningApplication[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Udp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Udp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Udp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaNetworkInstance_NetworkInstance_Udp_ListeningApplication struct, which is a YANG list entry.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Udp_ListeningApplication) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LocalAddress == nil {
		return nil, fmt.Errorf("nil value for key LocalAddress")
	}

	if t.LocalPort == nil {
		return nil, fmt.Errorf("nil value for key LocalPort")
	}

	return map[string]interface{}{
		"local-address": *t.LocalAddress,
		"local-port": *t.LocalPort,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Udp_ListeningApplication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Udp_ListeningApplication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Udp_ListeningApplication) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Udp_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaNetworkInstance_NetworkInstance_Udp_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaNetworkInstance_NetworkInstance_Udp_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewControl creates a new entry in the Control list of the
// SrlNokiaPlatform_Platform struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform) NewControl(Slot string) (*SrlNokiaPlatform_Platform_Control, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Control == nil {
		t.Control = make(map[string]*SrlNokiaPlatform_Platform_Control)
	}

	key := Slot

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Control[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Control", key)
	}

	t.Control[key] = &SrlNokiaPlatform_Platform_Control{
		Slot: &Slot,
	}

	return t.Control[key], nil
}

// NewFabric creates a new entry in the Fabric list of the
// SrlNokiaPlatform_Platform struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform) NewFabric(Slot uint8) (*SrlNokiaPlatform_Platform_Fabric, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Fabric == nil {
		t.Fabric = make(map[uint8]*SrlNokiaPlatform_Platform_Fabric)
	}

	key := Slot

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Fabric[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Fabric", key)
	}

	t.Fabric[key] = &SrlNokiaPlatform_Platform_Fabric{
		Slot: &Slot,
	}

	return t.Fabric[key], nil
}

// NewFanTray creates a new entry in the FanTray list of the
// SrlNokiaPlatform_Platform struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform) NewFanTray(Id uint8) (*SrlNokiaPlatform_Platform_FanTray, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.FanTray == nil {
		t.FanTray = make(map[uint8]*SrlNokiaPlatform_Platform_FanTray)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.FanTray[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list FanTray", key)
	}

	t.FanTray[key] = &SrlNokiaPlatform_Platform_FanTray{
		Id: &Id,
	}

	return t.FanTray[key], nil
}

// NewLinecard creates a new entry in the Linecard list of the
// SrlNokiaPlatform_Platform struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform) NewLinecard(Slot uint8) (*SrlNokiaPlatform_Platform_Linecard, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Linecard == nil {
		t.Linecard = make(map[uint8]*SrlNokiaPlatform_Platform_Linecard)
	}

	key := Slot

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Linecard[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Linecard", key)
	}

	t.Linecard[key] = &SrlNokiaPlatform_Platform_Linecard{
		Slot: &Slot,
	}

	return t.Linecard[key], nil
}

// NewPowerSupply creates a new entry in the PowerSupply list of the
// SrlNokiaPlatform_Platform struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform) NewPowerSupply(Id uint8) (*SrlNokiaPlatform_Platform_PowerSupply, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PowerSupply == nil {
		t.PowerSupply = make(map[uint8]*SrlNokiaPlatform_Platform_PowerSupply)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PowerSupply[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PowerSupply", key)
	}

	t.PowerSupply[key] = &SrlNokiaPlatform_Platform_PowerSupply{
		Id: &Id,
	}

	return t.PowerSupply[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Chassis"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Chassis) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis_Power) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Chassis_Power"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Chassis_Power) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Control) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Chassis_Power_Control"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Control) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Fabric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Chassis_Power_Fabric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Fabric) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_FanTray) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Chassis_Power_FanTray"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_FanTray) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Linecard) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Chassis_Power_Linecard"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Linecard) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Total) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Chassis_Power_Total"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Chassis_Power_Total) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewCpu creates a new entry in the Cpu list of the
// SrlNokiaPlatform_Platform_Control struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_Control) NewCpu(Index SrlNokiaPlatform_Platform_Control_Cpu_Index_Union) (*SrlNokiaPlatform_Platform_Control_Cpu, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Cpu == nil {
		t.Cpu = make(map[SrlNokiaPlatform_Platform_Control_Cpu_Index_Union]*SrlNokiaPlatform_Platform_Control_Cpu)
	}

	key := Index

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Cpu[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Cpu", key)
	}

	t.Cpu[key] = &SrlNokiaPlatform_Platform_Control_Cpu{
		Index: Index,
	}

	return t.Cpu[key], nil
}

// NewDisk creates a new entry in the Disk list of the
// SrlNokiaPlatform_Platform_Control struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_Control) NewDisk(Name string) (*SrlNokiaPlatform_Platform_Control_Disk, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Disk == nil {
		t.Disk = make(map[string]*SrlNokiaPlatform_Platform_Control_Disk)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Disk[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Disk", key)
	}

	t.Disk[key] = &SrlNokiaPlatform_Platform_Control_Disk{
		Name: &Name,
	}

	return t.Disk[key], nil
}

// NewProcess creates a new entry in the Process list of the
// SrlNokiaPlatform_Platform_Control struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_Control) NewProcess(Pid uint64) (*SrlNokiaPlatform_Platform_Control_Process, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Process == nil {
		t.Process = make(map[uint64]*SrlNokiaPlatform_Platform_Control_Process)
	}

	key := Pid

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Process[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Process", key)
	}

	t.Process[key] = &SrlNokiaPlatform_Platform_Control_Process{
		Pid: &Pid,
	}

	return t.Process[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Control struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Control) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Slot == nil {
		return nil, fmt.Errorf("nil value for key Slot")
	}

	return map[string]interface{}{
		"slot": *t.Slot,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Control_Cpu struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Control_Cpu) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"index": t.Index,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Cpu) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Cpu"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Cpu) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Cpu_HardwareInterrupt) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Cpu_HardwareInterrupt"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Cpu_HardwareInterrupt) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Cpu_Idle) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Cpu_Idle"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Cpu_Idle) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Cpu_Iowait) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Cpu_Iowait"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Cpu_Iowait) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Cpu_Nice) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Cpu_Nice"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Cpu_Nice) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Cpu_SoftwareInterrupt) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Cpu_SoftwareInterrupt"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Cpu_SoftwareInterrupt) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Cpu_System) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Cpu_System"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Cpu_System) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Cpu_Total) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Cpu_Total"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Cpu_Total) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Cpu_User) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Cpu_User"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Cpu_User) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewPartition creates a new entry in the Partition list of the
// SrlNokiaPlatform_Platform_Control_Disk struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_Control_Disk) NewPartition(Name string) (*SrlNokiaPlatform_Platform_Control_Disk_Partition, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Partition == nil {
		t.Partition = make(map[string]*SrlNokiaPlatform_Platform_Control_Disk_Partition)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Partition[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Partition", key)
	}

	t.Partition[key] = &SrlNokiaPlatform_Platform_Control_Disk_Partition{
		Name: &Name,
	}

	return t.Partition[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Control_Disk struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Control_Disk) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Disk) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Disk"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Disk) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Control_Disk_Partition struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Control_Disk_Partition) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Disk_Partition) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Disk_Partition"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Disk_Partition) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Disk_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Disk_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Disk_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Memory) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Memory"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Memory) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Power) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Power"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Power) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Control_Process struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Control_Process) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Pid == nil {
		return nil, fmt.Errorf("nil value for key Pid")
	}

	return map[string]interface{}{
		"pid": *t.Pid,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Process) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Process"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Process) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Control_Temperature) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Control_Temperature"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Control_Temperature) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Fabric struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Fabric) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Slot == nil {
		return nil, fmt.Errorf("nil value for key Slot")
	}

	return map[string]interface{}{
		"slot": *t.Slot,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Fabric) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Fabric"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Fabric) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Fabric_Power) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Fabric_Power"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Fabric_Power) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Fabric_Temperature) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Fabric_Temperature"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Fabric_Temperature) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_FanTray struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_FanTray) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_FanTray) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_FanTray"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_FanTray) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_FanTray_Power) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_FanTray_Power"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_FanTray_Power) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewForwardingComplex creates a new entry in the ForwardingComplex list of the
// SrlNokiaPlatform_Platform_Linecard struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_Linecard) NewForwardingComplex(Name E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name) (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ForwardingComplex == nil {
		t.ForwardingComplex = make(map[E_SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Name]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ForwardingComplex[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ForwardingComplex", key)
	}

	t.ForwardingComplex[key] = &SrlNokiaPlatform_Platform_Linecard_ForwardingComplex{
		Name: Name,
	}

	return t.ForwardingComplex[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Linecard struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Linecard) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Slot == nil {
		return nil, fmt.Errorf("nil value for key Slot")
	}

	return map[string]interface{}{
		"slot": *t.Slot,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewResource creates a new entry in the Resource list of the
// SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Acl struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Acl) NewResource(Name E_SrlNokiaPlatformAcl_AclResources) (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Acl_Resource, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformAcl_AclResources]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Acl_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Acl_Resource{
		Name: Name,
	}

	return t.Resource[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Acl) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Acl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Acl) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Acl_Resource struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Acl_Resource) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Acl_Resource) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Acl_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Acl_Resource) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory_Dram) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory_Dram"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory_Dram) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory_Sram) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory_Sram"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_BufferMemory_Sram) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewResource creates a new entry in the Resource list of the
// SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_IpMplsForwarding struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_IpMplsForwarding) NewResource(Name E_SrlNokiaPlatformIpMplsFwdResources_IpMplsForwardingResources) (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_IpMplsForwarding_Resource, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformIpMplsFwdResources_IpMplsForwardingResources]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_IpMplsForwarding_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_IpMplsForwarding_Resource{
		Name: Name,
	}

	return t.Resource[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_IpMplsForwarding) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_IpMplsForwarding"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_IpMplsForwarding) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_IpMplsForwarding_Resource struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_IpMplsForwarding_Resource) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_IpMplsForwarding_Resource) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_IpMplsForwarding_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_IpMplsForwarding_Resource) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewResource creates a new entry in the Resource list of the
// SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Mtu struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Mtu) NewResource(Name E_SrlNokiaPlatformMtu_MtuResources) (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Mtu_Resource, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformMtu_MtuResources]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Mtu_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Mtu_Resource{
		Name: Name,
	}

	return t.Resource[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Mtu) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Mtu"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Mtu) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Mtu_Resource struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Mtu_Resource) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Mtu_Resource) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Mtu_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Mtu_Resource) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewResource creates a new entry in the Resource list of the
// SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Qos struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Qos) NewResource(Name E_SrlNokiaPlatformQos_QosResources) (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Qos_Resource, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformQos_QosResources]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Qos_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Qos_Resource{
		Name: Name,
	}

	return t.Resource[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Qos) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Qos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Qos) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Qos_Resource struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Qos_Resource) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Qos_Resource) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Qos_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Qos_Resource) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewResource creates a new entry in the Resource list of the
// SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Tcam struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Tcam) NewResource(Name E_SrlNokiaPlatformAcl_TcamResources) (*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Tcam_Resource, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformAcl_TcamResources]*SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Tcam_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Tcam_Resource{
		Name: Name,
	}

	return t.Resource[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Tcam) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Tcam"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Tcam) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Tcam_Resource struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Tcam_Resource) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Tcam_Resource) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Tcam_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_ForwardingComplex_Tcam_Resource) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_Power) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_Power"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_Power) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Linecard_Temperature) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Linecard_Temperature"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Linecard_Temperature) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_PowerSupply struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_PowerSupply) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_PowerSupply) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_PowerSupply"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_PowerSupply) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_PowerSupply_Input) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_PowerSupply_Input"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_PowerSupply_Input) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_PowerSupply_Temperature) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_PowerSupply_Temperature"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_PowerSupply_Temperature) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Redundancy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Redundancy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Redundancy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Redundancy_Synchronization"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_Redundancy_Synchronization_Overlay) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewResource creates a new entry in the Resource list of the
// SrlNokiaPlatform_Platform_ResourceMonitoring_Acl struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl) NewResource(Name E_SrlNokiaPlatformAcl_AclResources) (*SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformAcl_AclResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource{
		Name: Name,
	}

	return t.Resource[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Acl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Acl_Resource) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewResource creates a new entry in the Resource list of the
// SrlNokiaPlatform_Platform_ResourceMonitoring_IpMplsForwarding struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_IpMplsForwarding) NewResource(Name E_SrlNokiaPlatformIpMplsFwdResources_IpMplsForwardingResources) (*SrlNokiaPlatform_Platform_ResourceMonitoring_IpMplsForwarding_Resource, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformIpMplsFwdResources_IpMplsForwardingResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_IpMplsForwarding_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &SrlNokiaPlatform_Platform_ResourceMonitoring_IpMplsForwarding_Resource{
		Name: Name,
	}

	return t.Resource[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_IpMplsForwarding) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_IpMplsForwarding"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_IpMplsForwarding) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_ResourceMonitoring_IpMplsForwarding_Resource struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_IpMplsForwarding_Resource) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_IpMplsForwarding_Resource) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_IpMplsForwarding_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_IpMplsForwarding_Resource) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewResource creates a new entry in the Resource list of the
// SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu) NewResource(Name E_SrlNokiaPlatformMtu_MtuResources) (*SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformMtu_MtuResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource{
		Name: Name,
	}

	return t.Resource[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Mtu_Resource) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewResource creates a new entry in the Resource list of the
// SrlNokiaPlatform_Platform_ResourceMonitoring_Qos struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos) NewResource(Name E_SrlNokiaPlatformQos_QosResources) (*SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformQos_QosResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource{
		Name: Name,
	}

	return t.Resource[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Qos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Qos_Resource) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewResource creates a new entry in the Resource list of the
// SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam) NewResource(Name E_SrlNokiaPlatformAcl_TcamResources) (*SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Resource == nil {
		t.Resource = make(map[E_SrlNokiaPlatformAcl_TcamResources]*SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Resource[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Resource", key)
	}

	t.Resource[key] = &SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource{
		Name: Name,
	}

	return t.Resource[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource struct, which is a YANG list entry.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"name": t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaPlatform_Platform_ResourceMonitoring_Tcam_Resource) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewDscpPolicy creates a new entry in the DscpPolicy list of the
// SrlNokiaQos_Qos_Classifiers struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Classifiers) NewDscpPolicy(Name string) (*SrlNokiaQos_Qos_Classifiers_DscpPolicy, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DscpPolicy == nil {
		t.DscpPolicy = make(map[string]*SrlNokiaQos_Qos_Classifiers_DscpPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DscpPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DscpPolicy", key)
	}

	t.DscpPolicy[key] = &SrlNokiaQos_Qos_Classifiers_DscpPolicy{
		Name: &Name,
	}

	return t.DscpPolicy[key], nil
}

// NewMplsTrafficClassPolicy creates a new entry in the MplsTrafficClassPolicy list of the
// SrlNokiaQos_Qos_Classifiers struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Classifiers) NewMplsTrafficClassPolicy(Name string) (*SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MplsTrafficClassPolicy == nil {
		t.MplsTrafficClassPolicy = make(map[string]*SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MplsTrafficClassPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MplsTrafficClassPolicy", key)
	}

	t.MplsTrafficClassPolicy[key] = &SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy{
		Name: &Name,
	}

	return t.MplsTrafficClassPolicy[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewDscp creates a new entry in the Dscp list of the
// SrlNokiaQos_Qos_Classifiers_DscpPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy) NewDscp(Value uint8) (*SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dscp == nil {
		t.Dscp = make(map[uint8]*SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Dscp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Dscp", key)
	}

	t.Dscp[key] = &SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp{
		Value: &Value,
	}

	return t.Dscp[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Classifiers_DscpPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_DscpPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_DscpPolicy_Dscp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewTrafficClass creates a new entry in the TrafficClass list of the
// SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) NewTrafficClass(Value uint8) (*SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrafficClass == nil {
		t.TrafficClass = make(map[uint8]*SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TrafficClass[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TrafficClass", key)
	}

	t.TrafficClass[key] = &SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass{
		Value: &Value,
	}

	return t.TrafficClass[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Value == nil {
		return nil, fmt.Errorf("nil value for key Value")
	}

	return map[string]interface{}{
		"value": *t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_Classifiers_MplsTrafficClassPolicy_TrafficClass) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewDscpPolicy creates a new entry in the DscpPolicy list of the
// SrlNokiaQos_Qos_RewriteRules struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules) NewDscpPolicy(Name string) (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DscpPolicy == nil {
		t.DscpPolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DscpPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DscpPolicy", key)
	}

	t.DscpPolicy[key] = &SrlNokiaQos_Qos_RewriteRules_DscpPolicy{
		Name: &Name,
	}

	return t.DscpPolicy[key], nil
}

// NewMplsTrafficClassPolicy creates a new entry in the MplsTrafficClassPolicy list of the
// SrlNokiaQos_Qos_RewriteRules struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules) NewMplsTrafficClassPolicy(Name string) (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MplsTrafficClassPolicy == nil {
		t.MplsTrafficClassPolicy = make(map[string]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MplsTrafficClassPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MplsTrafficClassPolicy", key)
	}

	t.MplsTrafficClassPolicy[key] = &SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy{
		Name: &Name,
	}

	return t.MplsTrafficClassPolicy[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewMap creates a new entry in the Map list of the
// SrlNokiaQos_Qos_RewriteRules_DscpPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) NewMap(ForwardingClass E_SrlNokiaQos_ForwardingClass) (*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Map == nil {
		t.Map = make(map[E_SrlNokiaQos_ForwardingClass]*SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map)
	}

	key := ForwardingClass

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Map[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Map", key)
	}

	t.Map[key] = &SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map{
		ForwardingClass: ForwardingClass,
	}

	return t.Map[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_DscpPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_DscpPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"forwarding-class": t.ForwardingClass,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_DscpPolicy_Map) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewMap creates a new entry in the Map list of the
// SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) NewMap(ForwardingClass E_SrlNokiaQos_ForwardingClass) (*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Map == nil {
		t.Map = make(map[E_SrlNokiaQos_ForwardingClass]*SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map)
	}

	key := ForwardingClass

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Map[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Map", key)
	}

	t.Map[key] = &SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map{
		ForwardingClass: ForwardingClass,
	}

	return t.Map[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map struct, which is a YANG list entry.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"forwarding-class": t.ForwardingClass,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaQos_Qos_RewriteRules_MplsTrafficClassPolicy_Map) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewAsPathSet creates a new entry in the AsPathSet list of the
// SrlNokiaRoutingPolicy_RoutingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) NewAsPathSet(Name string) (*SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AsPathSet == nil {
		t.AsPathSet = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AsPathSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AsPathSet", key)
	}

	t.AsPathSet[key] = &SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet{
		Name: &Name,
	}

	return t.AsPathSet[key], nil
}

// NewCommunitySet creates a new entry in the CommunitySet list of the
// SrlNokiaRoutingPolicy_RoutingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) NewCommunitySet(Name string) (*SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CommunitySet == nil {
		t.CommunitySet = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.CommunitySet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list CommunitySet", key)
	}

	t.CommunitySet[key] = &SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet{
		Name: &Name,
	}

	return t.CommunitySet[key], nil
}

// NewPolicy creates a new entry in the Policy list of the
// SrlNokiaRoutingPolicy_RoutingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) NewPolicy(Name string) (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policy == nil {
		t.Policy = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_Policy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Policy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Policy", key)
	}

	t.Policy[key] = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy{
		Name: &Name,
	}

	return t.Policy[key], nil
}

// NewPrefixSet creates a new entry in the PrefixSet list of the
// SrlNokiaRoutingPolicy_RoutingPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) NewPrefixSet(Name string) (*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixSet == nil {
		t.PrefixSet = make(map[string]*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixSet[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixSet", key)
	}

	t.PrefixSet[key] = &SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet{
		Name: &Name,
	}

	return t.PrefixSet[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet struct, which is a YANG list entry.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_AsPathSet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet struct, which is a YANG list entry.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_CommunitySet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewStatement creates a new entry in the Statement list of the
// SrlNokiaRoutingPolicy_RoutingPolicy_Policy struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) NewStatement(SequenceId uint32) (*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Statement == nil {
		t.Statement = make(map[uint32]*SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement)
	}

	key := SequenceId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Statement[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Statement", key)
	}

	t.Statement[key] = &SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement{
		SequenceId: &SequenceId,
	}

	return t.Statement[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaRoutingPolicy_RoutingPolicy_Policy struct, which is a YANG list entry.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp_AsPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp_AsPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp_AsPath) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp_AsPath_Prepend) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp_AsPath_Prepend"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp_AsPath_Prepend) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp_Communities) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp_Communities"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp_Communities) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp_LocalPreference) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp_LocalPreference"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp_LocalPreference) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp_Origin) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp_Origin"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Accept_Bgp_Origin) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_NextEntry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_NextEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_NextEntry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_NextPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_NextPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_NextPolicy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Reject) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Reject"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_DefaultAction_Reject) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement struct, which is a YANG list entry.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SequenceId == nil {
		return nil, fmt.Errorf("nil value for key SequenceId")
	}

	return map[string]interface{}{
		"sequence-id": *t.SequenceId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp_AsPath) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp_AsPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp_AsPath) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp_AsPath_Prepend) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp_AsPath_Prepend"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp_AsPath_Prepend) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp_Communities) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp_Communities"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp_Communities) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp_LocalPreference) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp_LocalPreference"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp_LocalPreference) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp_Origin) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp_Origin"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Accept_Bgp_Origin) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_NextEntry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_NextEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_NextEntry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_NextPolicy) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_NextPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_NextPolicy) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Reject) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Reject"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Action_Reject) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_Policy_Statement_Match_Bgp_AsPathLength) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewPrefix creates a new entry in the Prefix list of the
// SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) NewPrefix(IpPrefix string, MaskLengthRange string) (*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix_Key]*SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix)
	}

	key := SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix_Key{
		IpPrefix: IpPrefix,
		MaskLengthRange: MaskLengthRange,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix{
		IpPrefix: &IpPrefix,
		MaskLengthRange: &MaskLengthRange,
	}

	return t.Prefix[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet struct, which is a YANG list entry.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix struct, which is a YANG list entry.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	if t.MaskLengthRange == nil {
		return nil, fmt.Errorf("nil value for key MaskLengthRange")
	}

	return map[string]interface{}{
		"ip-prefix": *t.IpPrefix,
		"mask-length-range": *t.MaskLengthRange,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaRoutingPolicy_RoutingPolicy_PrefixSet_Prefix) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewServerGroup creates a new entry in the ServerGroup list of the
// SrlNokiaSystem_System_Aaa struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Aaa) NewServerGroup(Name string) (*SrlNokiaSystem_System_Aaa_ServerGroup, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ServerGroup == nil {
		t.ServerGroup = make(map[string]*SrlNokiaSystem_System_Aaa_ServerGroup)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ServerGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ServerGroup", key)
	}

	t.ServerGroup[key] = &SrlNokiaSystem_System_Aaa_ServerGroup{
		Name: &Name,
	}

	return t.ServerGroup[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewEvent creates a new entry in the Event list of the
// SrlNokiaSystem_System_Aaa_Accounting struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Aaa_Accounting) NewEvent(EventType E_SrlNokiaAaaTypes_AaaAccountingEventType) (*SrlNokiaSystem_System_Aaa_Accounting_Event, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Event == nil {
		t.Event = make(map[E_SrlNokiaAaaTypes_AaaAccountingEventType]*SrlNokiaSystem_System_Aaa_Accounting_Event)
	}

	key := EventType

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Event[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Event", key)
	}

	t.Event[key] = &SrlNokiaSystem_System_Aaa_Accounting_Event{
		EventType: EventType,
	}

	return t.Event[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Accounting) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_Accounting"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_Accounting) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Aaa_Accounting_Event struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Aaa_Accounting_Event) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event-type": t.EventType,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Accounting_Event) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_Accounting_Event"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_Accounting_Event) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewSession creates a new entry in the Session list of the
// SrlNokiaSystem_System_Aaa_Authentication struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Aaa_Authentication) NewSession(Id uint32) (*SrlNokiaSystem_System_Aaa_Authentication_Session, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[uint32]*SrlNokiaSystem_System_Aaa_Authentication_Session)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Session[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Session", key)
	}

	t.Session[key] = &SrlNokiaSystem_System_Aaa_Authentication_Session{
		Id: &Id,
	}

	return t.Session[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authentication) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_Authentication) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authentication_AdminUser) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_Authentication_AdminUser"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_Authentication_AdminUser) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Aaa_Authentication_Session struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Session) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Session) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_Authentication_Session"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_Authentication_Session) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewServer creates a new entry in the Server list of the
// SrlNokiaSystem_System_Aaa_ServerGroup struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) NewServer(Address string) (*SrlNokiaSystem_System_Aaa_ServerGroup_Server, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*SrlNokiaSystem_System_Aaa_ServerGroup_Server)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Server[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Server", key)
	}

	t.Server[key] = &SrlNokiaSystem_System_Aaa_ServerGroup_Server{
		Address: &Address,
	}

	return t.Server[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Aaa_ServerGroup struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_ServerGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Aaa_ServerGroup_Server struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_ServerGroup_Server"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_ServerGroup_Server_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Aaa_ServerGroup_Server_Tacacs) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewApplication creates a new entry in the Application list of the
// SrlNokiaSystem_System_AppManagement struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_AppManagement) NewApplication(Name string) (*SrlNokiaSystem_System_AppManagement_Application, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Application == nil {
		t.Application = make(map[string]*SrlNokiaSystem_System_AppManagement_Application)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Application[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Application", key)
	}

	t.Application[key] = &SrlNokiaSystem_System_AppManagement_Application{
		Name: &Name,
	}

	return t.Application[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_AppManagement) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_AppManagement"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_AppManagement) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_AppManagement_Application struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_AppManagement_Application) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_AppManagement_Application) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_AppManagement_Application"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_AppManagement_Application) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_AppManagement_Application_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_AppManagement_Application_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_AppManagement_Application_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_AppManagement_Application_Yang) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_AppManagement_Application_Yang"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_AppManagement_Application_Yang) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Banner) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Banner"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Banner) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Boot) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Boot"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Boot) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Boot_Autoboot) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Boot_Autoboot"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Boot_Autoboot) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Clock) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Clock"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Clock) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewCheckpoint creates a new entry in the Checkpoint list of the
// SrlNokiaSystem_System_Configuration struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Configuration) NewCheckpoint(Id uint8) (*SrlNokiaSystem_System_Configuration_Checkpoint, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Checkpoint == nil {
		t.Checkpoint = make(map[uint8]*SrlNokiaSystem_System_Configuration_Checkpoint)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Checkpoint[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Checkpoint", key)
	}

	t.Checkpoint[key] = &SrlNokiaSystem_System_Configuration_Checkpoint{
		Id: &Id,
	}

	return t.Checkpoint[key], nil
}

// NewSession creates a new entry in the Session list of the
// SrlNokiaSystem_System_Configuration struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Configuration) NewSession(Id uint32) (*SrlNokiaSystem_System_Configuration_Session, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Session == nil {
		t.Session = make(map[uint32]*SrlNokiaSystem_System_Configuration_Session)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Session[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Session", key)
	}

	t.Session[key] = &SrlNokiaSystem_System_Configuration_Session{
		Id: &Id,
	}

	return t.Session[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Configuration) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Configuration"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Configuration) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Configuration_Checkpoint struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Configuration_Checkpoint) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Configuration_Checkpoint) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Configuration_Checkpoint"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Configuration_Checkpoint) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Configuration_Session struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Configuration_Session) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Configuration_Session) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Configuration_Session"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Configuration_Session) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewHostEntry creates a new entry in the HostEntry list of the
// SrlNokiaSystem_System_Dns struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Dns) NewHostEntry(Name string) (*SrlNokiaSystem_System_Dns_HostEntry, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HostEntry == nil {
		t.HostEntry = make(map[string]*SrlNokiaSystem_System_Dns_HostEntry)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.HostEntry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list HostEntry", key)
	}

	t.HostEntry[key] = &SrlNokiaSystem_System_Dns_HostEntry{
		Name: &Name,
	}

	return t.HostEntry[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Dns) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Dns"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Dns) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Dns_HostEntry struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Dns_HostEntry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Dns_HostEntry) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Dns_HostEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Dns_HostEntry) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_FtpServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_FtpServer) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_FtpServer_NetworkInstance, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_FtpServer_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_FtpServer_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_FtpServer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_FtpServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_FtpServer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_FtpServer_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_FtpServer_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_FtpServer_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_GnmiServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_GnmiServer) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_GnmiServer_NetworkInstance, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_GnmiServer_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_GnmiServer_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// NewSubscription creates a new entry in the Subscription list of the
// SrlNokiaSystem_System_GnmiServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_GnmiServer) NewSubscription(Id uint32) (*SrlNokiaSystem_System_GnmiServer_Subscription, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subscription == nil {
		t.Subscription = make(map[uint32]*SrlNokiaSystem_System_GnmiServer_Subscription)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subscription[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subscription", key)
	}

	t.Subscription[key] = &SrlNokiaSystem_System_GnmiServer_Subscription{
		Id: &Id,
	}

	return t.Subscription[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GnmiServer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_GnmiServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_GnmiServer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_GnmiServer_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_GnmiServer_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_GnmiServer_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_GnmiServer_Subscription struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_GnmiServer_Subscription) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GnmiServer_Subscription) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_GnmiServer_Subscription"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_GnmiServer_Subscription) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_GnmiServer_UnixSocket"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_GnmiServer_UnixSocket) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Information) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Information"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Information) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_IpLoadBalancing) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_IpLoadBalancing"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_IpLoadBalancing) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_IpLoadBalancing_HashKeys) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_IpLoadBalancing_HashKeys"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_IpLoadBalancing_HashKeys) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_JsonRpcServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_JsonRpcServer) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_JsonRpcServer_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_JsonRpcServer_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_JsonRpcServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_JsonRpcServer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_JsonRpcServer_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_JsonRpcServer_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Http) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_JsonRpcServer_NetworkInstance_Https) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_JsonRpcServer_UnixSocket) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_JsonRpcServer_UnixSocket"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_JsonRpcServer_UnixSocket) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewInterface creates a new entry in the Interface list of the
// SrlNokiaSystem_System_Lldp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Lldp) NewInterface(Name string) (*SrlNokiaSystem_System_Lldp_Interface, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*SrlNokiaSystem_System_Lldp_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &SrlNokiaSystem_System_Lldp_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// NewManagementAddress creates a new entry in the ManagementAddress list of the
// SrlNokiaSystem_System_Lldp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Lldp) NewManagementAddress(Subinterface string) (*SrlNokiaSystem_System_Lldp_ManagementAddress, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ManagementAddress == nil {
		t.ManagementAddress = make(map[string]*SrlNokiaSystem_System_Lldp_ManagementAddress)
	}

	key := Subinterface

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ManagementAddress[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ManagementAddress", key)
	}

	t.ManagementAddress[key] = &SrlNokiaSystem_System_Lldp_ManagementAddress{
		Subinterface: &Subinterface,
	}

	return t.ManagementAddress[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_BgpAutoDiscovery"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_BgpAutoDiscovery) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewNeighbor creates a new entry in the Neighbor list of the
// SrlNokiaSystem_System_Lldp_Interface struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Lldp_Interface) NewNeighbor(Id string) (*SrlNokiaSystem_System_Lldp_Interface_Neighbor, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*SrlNokiaSystem_System_Lldp_Interface_Neighbor)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &SrlNokiaSystem_System_Lldp_Interface_Neighbor{
		Id: &Id,
	}

	return t.Neighbor[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Lldp_Interface struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Lldp_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_Interface) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_Interface_BgpAutoDiscovery) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewCapability creates a new entry in the Capability list of the
// SrlNokiaSystem_System_Lldp_Interface_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Lldp_Interface_Neighbor) NewCapability(Name string) (*SrlNokiaSystem_System_Lldp_Interface_Neighbor_Capability, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Capability == nil {
		t.Capability = make(map[string]*SrlNokiaSystem_System_Lldp_Interface_Neighbor_Capability)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Capability[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Capability", key)
	}

	t.Capability[key] = &SrlNokiaSystem_System_Lldp_Interface_Neighbor_Capability{
		Name: &Name,
	}

	return t.Capability[key], nil
}

// NewCustomTlv creates a new entry in the CustomTlv list of the
// SrlNokiaSystem_System_Lldp_Interface_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Lldp_Interface_Neighbor) NewCustomTlv(Type int32, Oui string, OuiSubtype string) (*SrlNokiaSystem_System_Lldp_Interface_Neighbor_CustomTlv, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CustomTlv == nil {
		t.CustomTlv = make(map[SrlNokiaSystem_System_Lldp_Interface_Neighbor_CustomTlv_Key]*SrlNokiaSystem_System_Lldp_Interface_Neighbor_CustomTlv)
	}

	key := SrlNokiaSystem_System_Lldp_Interface_Neighbor_CustomTlv_Key{
		Type: Type,
		Oui: Oui,
		OuiSubtype: OuiSubtype,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.CustomTlv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list CustomTlv", key)
	}

	t.CustomTlv[key] = &SrlNokiaSystem_System_Lldp_Interface_Neighbor_CustomTlv{
		Type: &Type,
		Oui: &Oui,
		OuiSubtype: &OuiSubtype,
	}

	return t.CustomTlv[key], nil
}

// NewManagementAddress creates a new entry in the ManagementAddress list of the
// SrlNokiaSystem_System_Lldp_Interface_Neighbor struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Lldp_Interface_Neighbor) NewManagementAddress(Address string) (*SrlNokiaSystem_System_Lldp_Interface_Neighbor_ManagementAddress, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ManagementAddress == nil {
		t.ManagementAddress = make(map[string]*SrlNokiaSystem_System_Lldp_Interface_Neighbor_ManagementAddress)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ManagementAddress[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ManagementAddress", key)
	}

	t.ManagementAddress[key] = &SrlNokiaSystem_System_Lldp_Interface_Neighbor_ManagementAddress{
		Address: &Address,
	}

	return t.ManagementAddress[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Lldp_Interface_Neighbor struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Lldp_Interface_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Id == nil {
		return nil, fmt.Errorf("nil value for key Id")
	}

	return map[string]interface{}{
		"id": *t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_Interface_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_Interface_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_Interface_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_Interface_Neighbor_BgpAutoDiscovery) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_Interface_Neighbor_BgpAutoDiscovery"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_Interface_Neighbor_BgpAutoDiscovery) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Lldp_Interface_Neighbor_Capability struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Lldp_Interface_Neighbor_Capability) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_Interface_Neighbor_Capability) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_Interface_Neighbor_Capability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_Interface_Neighbor_Capability) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Lldp_Interface_Neighbor_CustomTlv struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Lldp_Interface_Neighbor_CustomTlv) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Oui == nil {
		return nil, fmt.Errorf("nil value for key Oui")
	}

	if t.OuiSubtype == nil {
		return nil, fmt.Errorf("nil value for key OuiSubtype")
	}

	if t.Type == nil {
		return nil, fmt.Errorf("nil value for key Type")
	}

	return map[string]interface{}{
		"oui": *t.Oui,
		"oui-subtype": *t.OuiSubtype,
		"type": *t.Type,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_Interface_Neighbor_CustomTlv) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_Interface_Neighbor_CustomTlv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_Interface_Neighbor_CustomTlv) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Lldp_Interface_Neighbor_ManagementAddress struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Lldp_Interface_Neighbor_ManagementAddress) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_Interface_Neighbor_ManagementAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_Interface_Neighbor_ManagementAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_Interface_Neighbor_ManagementAddress) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_Interface_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_Interface_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_Interface_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Lldp_ManagementAddress struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Lldp_ManagementAddress) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Subinterface == nil {
		return nil, fmt.Errorf("nil value for key Subinterface")
	}

	return map[string]interface{}{
		"subinterface": *t.Subinterface,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_ManagementAddress) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_ManagementAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_ManagementAddress) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Lldp_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Lldp_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Lldp_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewBuffer creates a new entry in the Buffer list of the
// SrlNokiaSystem_System_Logging struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging) NewBuffer(BufferName string) (*SrlNokiaSystem_System_Logging_Buffer, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Buffer == nil {
		t.Buffer = make(map[string]*SrlNokiaSystem_System_Logging_Buffer)
	}

	key := BufferName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Buffer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Buffer", key)
	}

	t.Buffer[key] = &SrlNokiaSystem_System_Logging_Buffer{
		BufferName: &BufferName,
	}

	return t.Buffer[key], nil
}

// NewFile creates a new entry in the File list of the
// SrlNokiaSystem_System_Logging struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging) NewFile(FileName string) (*SrlNokiaSystem_System_Logging_File, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.File == nil {
		t.File = make(map[string]*SrlNokiaSystem_System_Logging_File)
	}

	key := FileName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.File[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list File", key)
	}

	t.File[key] = &SrlNokiaSystem_System_Logging_File{
		FileName: &FileName,
	}

	return t.File[key], nil
}

// NewFilter creates a new entry in the Filter list of the
// SrlNokiaSystem_System_Logging struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging) NewFilter(FilterName string) (*SrlNokiaSystem_System_Logging_Filter, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Filter == nil {
		t.Filter = make(map[string]*SrlNokiaSystem_System_Logging_Filter)
	}

	key := FilterName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Filter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Filter", key)
	}

	t.Filter[key] = &SrlNokiaSystem_System_Logging_Filter{
		FilterName: &FilterName,
	}

	return t.Filter[key], nil
}

// NewRemoteServer creates a new entry in the RemoteServer list of the
// SrlNokiaSystem_System_Logging struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging) NewRemoteServer(Host string) (*SrlNokiaSystem_System_Logging_RemoteServer, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RemoteServer == nil {
		t.RemoteServer = make(map[string]*SrlNokiaSystem_System_Logging_RemoteServer)
	}

	key := Host

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RemoteServer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RemoteServer", key)
	}

	t.RemoteServer[key] = &SrlNokiaSystem_System_Logging_RemoteServer{
		Host: &Host,
	}

	return t.RemoteServer[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewFacility creates a new entry in the Facility list of the
// SrlNokiaSystem_System_Logging_Buffer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_Buffer) NewFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) (*SrlNokiaSystem_System_Logging_Buffer_Facility, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Buffer_Facility)
	}

	key := FacilityName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Facility[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Facility", key)
	}

	t.Facility[key] = &SrlNokiaSystem_System_Logging_Buffer_Facility{
		FacilityName: FacilityName,
	}

	return t.Facility[key], nil
}

// NewSubsystem creates a new entry in the Subsystem list of the
// SrlNokiaSystem_System_Logging_Buffer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_Buffer) NewSubsystem(SubsystemName E_SrlNokiaLogging_SubsystemNameType) (*SrlNokiaSystem_System_Logging_Buffer_Subsystem, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_Buffer_Subsystem)
	}

	key := SubsystemName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subsystem[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subsystem", key)
	}

	t.Subsystem[key] = &SrlNokiaSystem_System_Logging_Buffer_Subsystem{
		SubsystemName: SubsystemName,
	}

	return t.Subsystem[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Buffer struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Buffer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.BufferName == nil {
		return nil, fmt.Errorf("nil value for key BufferName")
	}

	return map[string]interface{}{
		"buffer-name": *t.BufferName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Buffer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Buffer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Buffer_Facility struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"facility-name": t.FacilityName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Buffer_Facility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Buffer_Facility_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Buffer_Facility_Priority) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Buffer_Subsystem struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"subsystem-name": t.SubsystemName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Buffer_Subsystem"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Buffer_Subsystem_Priority) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewFacility creates a new entry in the Facility list of the
// SrlNokiaSystem_System_Logging_Console struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_Console) NewFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) (*SrlNokiaSystem_System_Logging_Console_Facility, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Console_Facility)
	}

	key := FacilityName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Facility[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Facility", key)
	}

	t.Facility[key] = &SrlNokiaSystem_System_Logging_Console_Facility{
		FacilityName: FacilityName,
	}

	return t.Facility[key], nil
}

// NewSubsystem creates a new entry in the Subsystem list of the
// SrlNokiaSystem_System_Logging_Console struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_Console) NewSubsystem(SubsystemName E_SrlNokiaLogging_SubsystemNameType) (*SrlNokiaSystem_System_Logging_Console_Subsystem, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_Console_Subsystem)
	}

	key := SubsystemName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subsystem[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subsystem", key)
	}

	t.Subsystem[key] = &SrlNokiaSystem_System_Logging_Console_Subsystem{
		SubsystemName: SubsystemName,
	}

	return t.Subsystem[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Console"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Console) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Console_Facility struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"facility-name": t.FacilityName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Console_Facility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Console_Facility) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Facility_Priority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Console_Facility_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Console_Facility_Priority) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Console_Subsystem struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"subsystem-name": t.SubsystemName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Console_Subsystem"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Console_Subsystem_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Console_Subsystem_Priority) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewFacility creates a new entry in the Facility list of the
// SrlNokiaSystem_System_Logging_File struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_File) NewFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) (*SrlNokiaSystem_System_Logging_File_Facility, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_File_Facility)
	}

	key := FacilityName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Facility[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Facility", key)
	}

	t.Facility[key] = &SrlNokiaSystem_System_Logging_File_Facility{
		FacilityName: FacilityName,
	}

	return t.Facility[key], nil
}

// NewSubsystem creates a new entry in the Subsystem list of the
// SrlNokiaSystem_System_Logging_File struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_File) NewSubsystem(SubsystemName E_SrlNokiaLogging_SubsystemNameType) (*SrlNokiaSystem_System_Logging_File_Subsystem, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_File_Subsystem)
	}

	key := SubsystemName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subsystem[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subsystem", key)
	}

	t.Subsystem[key] = &SrlNokiaSystem_System_Logging_File_Subsystem{
		SubsystemName: SubsystemName,
	}

	return t.Subsystem[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_File struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_File) ΛListKeyMap() (map[string]interface{}, error) {
	if t.FileName == nil {
		return nil, fmt.Errorf("nil value for key FileName")
	}

	return map[string]interface{}{
		"file-name": *t.FileName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_File"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_File) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_File_Facility struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_File_Facility) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"facility-name": t.FacilityName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Facility) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_File_Facility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_File_Facility) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Facility_Priority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_File_Facility_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_File_Facility_Priority) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_File_Subsystem struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"subsystem-name": t.SubsystemName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_File_Subsystem"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem_Priority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_File_Subsystem_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_File_Subsystem_Priority) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewFacility creates a new entry in the Facility list of the
// SrlNokiaSystem_System_Logging_Filter struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_Filter) NewFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) (*SrlNokiaSystem_System_Logging_Filter_Facility, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_Filter_Facility)
	}

	key := FacilityName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Facility[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Facility", key)
	}

	t.Facility[key] = &SrlNokiaSystem_System_Logging_Filter_Facility{
		FacilityName: FacilityName,
	}

	return t.Facility[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Filter struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Filter) ΛListKeyMap() (map[string]interface{}, error) {
	if t.FilterName == nil {
		return nil, fmt.Errorf("nil value for key FilterName")
	}

	return map[string]interface{}{
		"filter-name": *t.FilterName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Filter) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Filter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_Filter_Facility struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"facility-name": t.FacilityName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Filter_Facility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility_Priority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_Filter_Facility_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_Filter_Facility_Priority) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewFacility creates a new entry in the Facility list of the
// SrlNokiaSystem_System_Logging_RemoteServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) NewFacility(FacilityName E_SrlNokiaLogging_FacilityNameType) (*SrlNokiaSystem_System_Logging_RemoteServer_Facility, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Facility == nil {
		t.Facility = make(map[E_SrlNokiaLogging_FacilityNameType]*SrlNokiaSystem_System_Logging_RemoteServer_Facility)
	}

	key := FacilityName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Facility[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Facility", key)
	}

	t.Facility[key] = &SrlNokiaSystem_System_Logging_RemoteServer_Facility{
		FacilityName: FacilityName,
	}

	return t.Facility[key], nil
}

// NewSubsystem creates a new entry in the Subsystem list of the
// SrlNokiaSystem_System_Logging_RemoteServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) NewSubsystem(SubsystemName E_SrlNokiaLogging_SubsystemNameType) (*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Subsystem == nil {
		t.Subsystem = make(map[E_SrlNokiaLogging_SubsystemNameType]*SrlNokiaSystem_System_Logging_RemoteServer_Subsystem)
	}

	key := SubsystemName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Subsystem[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Subsystem", key)
	}

	t.Subsystem[key] = &SrlNokiaSystem_System_Logging_RemoteServer_Subsystem{
		SubsystemName: SubsystemName,
	}

	return t.Subsystem[key], nil
}

// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_RemoteServer struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Host == nil {
		return nil, fmt.Errorf("nil value for key Host")
	}

	return map[string]interface{}{
		"host": *t.Host,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_RemoteServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_RemoteServer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_RemoteServer_Facility struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"facility-name": t.FacilityName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_RemoteServer_Facility"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Facility_Priority) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Logging_RemoteServer_Subsystem struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"subsystem-name": t.SubsystemName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_RemoteServer_Subsystem"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Logging_RemoteServer_Subsystem_Priority) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewGroup creates a new entry in the Group list of the
// SrlNokiaSystem_System_Maintenance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Maintenance) NewGroup(Name string) (*SrlNokiaSystem_System_Maintenance_Group, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Group == nil {
		t.Group = make(map[string]*SrlNokiaSystem_System_Maintenance_Group)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Group[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Group", key)
	}

	t.Group[key] = &SrlNokiaSystem_System_Maintenance_Group{
		Name: &Name,
	}

	return t.Group[key], nil
}

// NewProfile creates a new entry in the Profile list of the
// SrlNokiaSystem_System_Maintenance struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Maintenance) NewProfile(Name string) (*SrlNokiaSystem_System_Maintenance_Profile, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Profile == nil {
		t.Profile = make(map[string]*SrlNokiaSystem_System_Maintenance_Profile)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Profile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Profile", key)
	}

	t.Profile[key] = &SrlNokiaSystem_System_Maintenance_Profile{
		Name: &Name,
	}

	return t.Profile[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Maintenance_Group struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Maintenance_Group) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Group"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Group) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Group_MaintenanceMode) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Group_Members"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_Maintenance_Group_Members_Bgp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Group_Members_Bgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Group_Members_Bgp_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Maintenance_Profile struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Maintenance_Profile) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Profile) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Profile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Profile) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Bgp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Maintenance_Profile_Bgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Maintenance_Profile_Bgp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Mtu) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Mtu"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Mtu) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Name) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Name"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Name) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewServer creates a new entry in the Server list of the
// SrlNokiaSystem_System_Ntp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Ntp) NewServer(Address string) (*SrlNokiaSystem_System_Ntp_Server, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Server == nil {
		t.Server = make(map[string]*SrlNokiaSystem_System_Ntp_Server)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Server[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Server", key)
	}

	t.Server[key] = &SrlNokiaSystem_System_Ntp_Server{
		Address: &Address,
	}

	return t.Server[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Ntp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Ntp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Ntp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Ntp_Server struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Ntp_Server) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Ntp_Server) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Ntp_Server"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Ntp_Server) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewCollector creates a new entry in the Collector list of the
// SrlNokiaSystem_System_Sflow struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Sflow) NewCollector(CollectorId uint16) (*SrlNokiaSystem_System_Sflow_Collector, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Collector == nil {
		t.Collector = make(map[uint16]*SrlNokiaSystem_System_Sflow_Collector)
	}

	key := CollectorId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Collector[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Collector", key)
	}

	t.Collector[key] = &SrlNokiaSystem_System_Sflow_Collector{
		CollectorId: &CollectorId,
	}

	return t.Collector[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sflow) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sflow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sflow) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Sflow_Collector struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Sflow_Collector) ΛListKeyMap() (map[string]interface{}, error) {
	if t.CollectorId == nil {
		return nil, fmt.Errorf("nil value for key CollectorId")
	}

	return map[string]interface{}{
		"collector-id": *t.CollectorId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sflow_Collector) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sflow_Collector"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sflow_Collector) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Sflow_Statistics) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Sflow_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Sflow_Statistics) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_Snmp struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Snmp) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_Snmp_NetworkInstance, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_Snmp_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_Snmp_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Snmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Snmp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Snmp_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Snmp_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Snmp_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewNetworkInstance creates a new entry in the NetworkInstance list of the
// SrlNokiaSystem_System_SshServer struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_SshServer) NewNetworkInstance(Name string) (*SrlNokiaSystem_System_SshServer_NetworkInstance, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NetworkInstance == nil {
		t.NetworkInstance = make(map[string]*SrlNokiaSystem_System_SshServer_NetworkInstance)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NetworkInstance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NetworkInstance", key)
	}

	t.NetworkInstance[key] = &SrlNokiaSystem_System_SshServer_NetworkInstance{
		Name: &Name,
	}

	return t.NetworkInstance[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_SshServer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_SshServer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_SshServer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_SshServer_NetworkInstance struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_SshServer_NetworkInstance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_SshServer_NetworkInstance) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// NewServerProfile creates a new entry in the ServerProfile list of the
// SrlNokiaSystem_System_Tls struct. The keys of the list are populated from the input
// arguments.
func (t *SrlNokiaSystem_System_Tls) NewServerProfile(Name string) (*SrlNokiaSystem_System_Tls_ServerProfile, error){

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ServerProfile == nil {
		t.ServerProfile = make(map[string]*SrlNokiaSystem_System_Tls_ServerProfile)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ServerProfile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ServerProfile", key)
	}

	t.ServerProfile[key] = &SrlNokiaSystem_System_Tls_ServerProfile{
		Name: &Name,
	}

	return t.ServerProfile[key], nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Tls) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Tls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Tls) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


// ΛListKeyMap returns the keys of the SrlNokiaSystem_System_Tls_ServerProfile struct, which is a YANG list entry.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["SrlNokiaSystem_System_Tls_ServerProfile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *SrlNokiaSystem_System_Tls_ServerProfile) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }


